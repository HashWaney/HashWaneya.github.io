<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HashWaney</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="HashWaney">
<meta property="og:url" content="http://hashwaney.github.io/index.html">
<meta property="og:site_name" content="HashWaney">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="HashWaney">
<meta property="article:tag" content="coder">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HashWaney" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HashWaney</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Action and Thinking</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hashwaney.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2020-05-04T02:15:39.294Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E9%9D%A2%E8%AF%95/">面试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>App启动到主页面经历过程</p>
<p><a href="https://www.jianshu.com/p/a72c5ccbd150" target="_blank" rel="noopener">https://www.jianshu.com/p/a72c5ccbd150</a></p>
<p><a href="https://www.yuque.com/richuangangban/mtbug7/ckek0r#efUyj" target="_blank" rel="noopener">https://www.yuque.com/richuangangban/mtbug7/ckek0r#efUyj</a></p>
<p><a href="https://www.yuque.com/docs/share/73271436-56d3-4c63-9311-ae499378198a" target="_blank" rel="noopener">https://www.yuque.com/docs/share/73271436-56d3-4c63-9311-ae499378198a</a></p>
<p><a href="https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Android相关/Android高级面试题.md" target="_blank" rel="noopener">https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Android%E7%9B%B8%E5%85%B3/Android%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/04/%E9%9D%A2%E8%AF%95/" data-id="ck9sievu7000mls3b8b6xc3iz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vultr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/Vultr/" class="article-date">
  <time datetime="2020-05-04T01:34:12.684Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/Vultr/">Vultr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vultr搭建SS步骤"><a href="#Vultr搭建SS步骤" class="headerlink" title="Vultr搭建SS步骤"></a>Vultr搭建SS步骤</h3><hr>
<p>自动一键安装SS</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>

<p>输入SS的密码，端口和加密方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Please enter password for shadowsocks-python</span><br><span class="line">(Default password: teddysun.com):your password</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">password = your password </span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line">Please enter a port for shadowsocks-python [1-65535]</span><br><span class="line">(Default port: 10853):your port </span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">port = your port </span><br><span class="line">---------------------------</span><br><span class="line">Please select stream cipher for shadowsocks-python:</span><br><span class="line">1) aes-256-gcm</span><br><span class="line">2) aes-192-gcm</span><br><span class="line">3) aes-128-gcm</span><br><span class="line">4) aes-256-ctr</span><br><span class="line">5) aes-192-ctr</span><br><span class="line">6) aes-128-ctr</span><br><span class="line">7) aes-256-cfb</span><br><span class="line">8) aes-192-cfb</span><br><span class="line">9) aes-128-cfb</span><br><span class="line">10) camellia-128-cfb</span><br><span class="line">11) camellia-192-cfb</span><br><span class="line">12) camellia-256-cfb</span><br><span class="line">13) chacha20-ietf-poly1305</span><br><span class="line">14) chacha20-ietf</span><br><span class="line">15) chacha20</span><br><span class="line">16) rc4-md5</span><br><span class="line">Which cipher you'd select(Default: aes-256-gcm):7</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">cipher = aes-256-cfb</span><br><span class="line">---------------------------</span><br><span class="line">Congratulations, Shadowsocks-python server install completed!</span><br><span class="line">Your Server IP        :  your ip address</span><br><span class="line">Your Server Port      :  your port </span><br><span class="line">Your Password         :  your password</span><br><span class="line">Your Encryption Method:  aes-256-cfb </span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/342.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/04/Vultr/" data-id="ck9sievu4000els3be6xq4cb6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Android%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Android%E5%A4%8D%E4%B9%A0/">Android面试集锦（一）内存泄露篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Android中常见的内存泄露汇总</strong></p>
<ul>
<li><p><strong>单例造成的内存泄露</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Holder holder;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context =context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(holder==<span class="keyword">null</span>)&#123;</span><br><span class="line">            holder =<span class="keyword">new</span> Holder(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的单例模式，注意这里的Context 的生命周期长短决定了是否会发生内存泄露</span></span><br><span class="line"><span class="number">1</span>.如果是Application的Context，不会有啥问题，因为静态变量的生命周期和Application的Context的生命周期一样长；</span><br><span class="line"><span class="number">2</span>.如果传入的是Activity的Context，那么当Activity退出了，该Context的引用被单例对象持有，无法得到内存释放，因此无法释放，就造成了内存泄露；</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>集合类泄露</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的集合持有Object的引用，当object=null仅仅是释放了引用本身，</span></span><br><span class="line"><span class="comment">//Vector这个静态变量仍然引用该对象，所以这个对象对于GC来说是不可以回收的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Object&gt; vector =<span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    vector.add(obj);</span><br><span class="line">    object=<span class="keyword">null</span>; <span class="comment">//仅仅是释放了对象本身的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化方案，释放静态变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector =<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非静态内部类创建一个静态实例</strong></p>
<p>非静态内部类创建了一个静态的实例对象，该实例对象生命周期和应用的生命周期一样长，然而非静态内部类是会去持有外部类的引用的，就好比有了父子之间的关系，在一个类中创建了内部类，他们就有关系了，</p>
<p>内部类持有外部类的名片表明自己是谁家的。OK，那么既然非静态内部类创建了一个静态实例变量，那么意味着静态变量持有了Activity的引用，那么又是去比较生命周期了，静态变量的生命周期很长，那么Activity总会销毁，但是静态变量持有它的引用，意味着它是可达的，根据GC的回收算法，如果一个对象不可达说明其是可以进行回收的，既然Activity已经销毁了，没作用了，但是难点听占着茅坑不拉屎，占用一部分内存空间，这样导致无法回收了，就会造成Activity的内存泄露了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceManager mResourceManager =<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResourceManager==<span class="keyword">null</span>)&#123;</span><br><span class="line">            mResourceManager = <span class="keyword">new</span> ResourceManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ResourceManager</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//为了防止内存泄露,将该内部置空</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mResourceManager=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以将该内部类设为静态内部类，</span></span><br><span class="line"><span class="comment">//也可以将该内部类抽取出来封装为一个单例对象；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匿名内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Runnable reference1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Runnable reference2 =<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(reference1).start();</span><br><span class="line">    <span class="comment">//解决方案：静态内部类 异步线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原因：匿名内部类会持有当前MainActivity.this,如果将这个引用传入到一个异步线程中,此线程和Activity的生命周期不一致的时候，有可能Activity此时跳转页面销毁了，而线程还没有结束生命，这个时候就会发生MainActivity的内存泄露</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Handler</strong></p>
<p>Handler、Message、MessageQueue都是相互关联起来的，如果Handler发送的Message没有被处理，那么</p>
<p>Handler和Message就会被MessageQueue一直持有，因为消息始终是需要Handler去MessageQueue中去取以及处理的，</p>
<p>那么假如在主线程中发送一个延迟10分钟的消息，Handler把发送到消息队列中，那么这个时候Activity突然被finish掉了，延迟执行的Message还会继续存在主线程中，该Message会持有Handler引用，然后Handler是声明称非静态内部类，它会持有Activity的引用，那么在Activity调用finish就不会进行回收了，从而导致内存泄露；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHandleLeakActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakHandler = <span class="keyword">new</span> Handler&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle args)</span></span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.onCreate(args);</span><br><span class="line">          mLeakHandler.postDelayed(<span class="keyword">new</span> Runnable&#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="comment">// ... </span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,<span class="number">1000</span>*<span class="number">60</span>*<span class="number">10</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//此时突然调用finish();</span></span><br><span class="line">          finish();</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 解决版本////</span></span><br><span class="line">  <span class="number">1</span>.将Handler声明为静态内部类</span><br><span class="line">  <span class="number">2</span>.将Activity声明为弱引用供Handler使用，使用之前进行判空处理</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> LeakHandler mHandler = <span class="keyword">new</span> LeakHandler(<span class="keyword">this</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle args)</span></span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.onCreate(args);</span><br><span class="line">          mHandler.postDelayed(sRunnable,<span class="number">1000</span>*<span class="number">60</span>*<span class="number">10</span>);</span><br><span class="line">          finish();</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//移除MessageQueue中的消息，</span></span><br><span class="line">         	<span class="comment">//防止Looper线程中的消息队列还有可能要处理的消息，这里我已经销毁了，</span></span><br><span class="line">          <span class="comment">//将不再处理消息了</span></span><br><span class="line">          mHandler.removeCallbackAndMessages(<span class="keyword">null</span>);</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;XXXActivity&gt; act;</span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="title">LeakHandler</span><span class="params">(XXXActivity activity)</span></span>&#123;</span><br><span class="line">              act =<span class="keyword">new</span> WeakReference&lt;XXXActivity&gt;(activity);</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message m)</span></span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(ref.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  <span class="comment">//....</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//自然这里的Runnable也需要声明为静态的实例和静态的Handler保持一致</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Runnable sRunnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综述：即推荐静态内部了+WeakReference方法，每次使用之前注意判空；</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>回收时机</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强</td>
<td>从来不会</td>
<td>new 创建出来的对象，提供对象的一般属性</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软</td>
<td>在内存不足时</td>
<td>联合ReferenceQueue构造有效期短/占用内存大/生命周期长的对象的二级高速缓冲器（内存不足才清空）</td>
<td>内存不足终止</td>
</tr>
<tr>
<td>弱</td>
<td>垃圾回收时</td>
<td>联合ReferenceQueue构造有效期短/占用内存大/生命周期长的对象的一级高速缓冲器（系统发生gc则清空）</td>
<td>gc运行后终止</td>
</tr>
<tr>
<td>虚</td>
<td>垃圾回收时</td>
<td>联合ReferenceQueue来跟踪对象被垃圾回收器回收的活动</td>
<td>gc运行后终止</td>
</tr>
</tbody></table>
<p>  在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量的使用软引用和弱引用技术；</p>
<p>  软/弱引用可以和一个引用队列（ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引入队列中，利用这个引用队列可以得知被回收的软/弱引用的对象列表，从而可以告知缓冲器清除已经失效的软/弱引用；</p>
<p>  <strong>应用：如果程序中大量默认图片，比如默认的头像，默认的logo等等，这些图片很多地方用到，如果每次取读取图片，如果每次去读取图片，由于读取文件需要IO操作，速度慢，性能地下，可以考虑将图片缓存起来，需要的时候直接从内存中读取，由于图片占用内存空间比较大，缓存很多图片需要很多内存，可能就会发生OOM，考虑使用软/弱引用技术来避免这个问题发生。</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String,SoftReference&lt;Bitmap&gt;&gt;imageCache =<span class="keyword">new</span> HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类，用来保存Bitmap的软引用到HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBitmapUtil</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个HashMap,保存软引用对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache =<span class="keyword">new</span> HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，保存Bitmap的软引用到HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//强引用的Bitmap对象</span></span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">        <span class="comment">//将强引用转换为软引用Bitmap对象</span></span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line">        <span class="comment">//添加软引用Bitmap到Map中，加载到内存</span></span><br><span class="line">        imageCache.put(path,softBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Bitmap对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapByPath</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从缓存中获取软引用的Bitmap对象</span></span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get();</span><br><span class="line">        <span class="comment">//判断软引用是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(softBitmap==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过软引用取出Bitmap对象，如果由于内存不足Bitmap被回收，将取空，</span></span><br><span class="line">        <span class="comment">//如果未被回收，则可重复使用，提供速度</span></span><br><span class="line">        <span class="keyword">if</span>(softBitmap.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> softBitmap.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>使用软引用后，在发生OOM异常之前，这些缓存的图片资源的内存空间可以被释放掉，从而避免因为内存达到上限，防止Crash发生</strong></p>
<p>  如果对象可能经常使用，尽量使用软引用，如果对象使用不频繁，使用弱引用    </p>
<ul>
<li><p><strong>尽量避免使用static成员变量</strong></p>
<p>如果成员变量被声明为static，那么我们知道其生命周期将与整个app进程生命周期一样，</p>
<p>问题1.如果app进程设计上是常驻内存的，即使app切换到后台，这部分内存也不会被释放，按照app内存管理机制，占用内存较大的后台进程将优先回收；如果app做过进程互相保活的，会造成app在后台频繁重启，会消耗电量流量。app容易被用户卸载和静默</p>
<p>修复：</p>
<p>不要在类初始化时候初始化静态变量成员，可以使用lazy初始化，管理好对象的生命周期，如果应用退出，合理的进行对象的销毁操作；</p>
</li>
<li><p><strong>资源未关闭</strong></p>
<p>对于使用了BroadcastReceiver、ContentObserver、File、Cursor、Stream、Bitmap等资源，应该在Activity销魂的时候及时关闭，否则这些资源将不会被回收，造成内存泄露</p>
</li>
<li><p><strong>不良代码造成的内存压力</strong></p>
<p>比如Bitmap没有调用recycle()方法，对于Bitmap对象在不使用的时候，应该调用recycle()释放内存，然后才把它置为null；因为加载Bitmap对象的内存空间，一部分是Java的，一部分是C的（bitmap的分配底层是通过JNI调用的）recycle就是针对C部分的内存释放；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bitmap bitmap =<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">getBitmap</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bitmap!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        bitmap.recycle();</span><br><span class="line">        bitmap=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>总结</strong></p>
<p>1.对于Activity等组件的引用应该控制在Activity的生命周期之内，如果不能考虑使用getApplicationContext() 或者getApplication；以避免Activity被外部生命周期长的对象引用而导致了内存泄漏；</p>
<p>2.尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（类变量）《包括context》即使要使用，也要考虑在适当时候将外部成员变量置空，也可以在内部类中使用弱引用来引用外部类的变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将内部类改为静态内部类</span><br><span class="line">改造完之后的静态内部类使用弱引用来引用外部类的成员变量</span><br></pre></td></tr></table></figure>

<p>3.Handler持有的引用对象最好使用弱引用，资源释放时候也可以清空Handler里的消息（Hnadler.removeCallback());–调用时机（Activity的onStop 和 onDestroy执行时候）</p>
<p>4.Java的实现过程中，也要考虑其对象的释放，最好的方法就是在不使用某对象的时候，显示地将对象赋值为null.比如使用完了Bitmap，调用recycle，在赋值为null，清空对图片资源的直接饮用或间接引用，数组（array.clear() ; array=null)</p>
<p>5.正确关闭资源，对于使用了BroadcastReceiver,ContentObserver,File,Cursor,Stream,Bitmap资源，在Activity销毁时候及时的关闭和注销；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Android%E5%A4%8D%E4%B9%A0/" data-id="ck9sievts0000ls3b6ljlbs9s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/" rel="tag">面试集锦</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(三)线程池之Callable和Future" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/">Java多线程（三）线程池Callable 和 Future</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>线程池概念和Executors类的应用</strong></p>
<p>在TCP服务器编程模型中，当一个客户端连接到服务器，服务器要起一个线程为之服务，当客户端的会话结束后，</p>
<p>线程也就结束。</p>
<p>即每一个客户端连接，服务器就要为之创建一个新的线程。</p>
<p>如果访问服务器的客户端很多，那么服务器就会不断的创建和销毁线程，那么这样就严重影响服务器的性能；</p>
<p>怎么解决：</p>
<p>可以创建一些线程，这些线程构成的集合就称为线程池，当服务器接收到一个客户端请求后，就从线程池中取出一个空闲的线程，服务完成之后，不关闭该线程，而是将该线程还回线程池中。</p>
<p>在线程池的编程模式下，任务是交给整个线程池的，而不是直接交给某个线程；</p>
<p>线程池拿到任务后，就在内部找有空闲的线程，再把任务交给某个空闲的线程，</p>
<p><strong>任务是交给整个线程池，但是可以同时向一个线程池中提交多个任务。</strong></p>
<p>#####一些常用的线程池API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建固定大小的线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">threadPool.execute(Runnable runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建缓存的线程池（如果线程不够自动创建新的线程满足服务）</span></span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">threadPool.execute(Runnable runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单一线程池（线程池里面只有一个线程，如果意外死亡，那么系统就自动创建一个新的线程来代替）</span></span><br><span class="line">ExecutorService	threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">threadPool.execute(Runnable runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行完任务后关闭线程池</span></span><br><span class="line">threadPool.shutdown();</span><br><span class="line"><span class="comment">//不管任务是否完成都关闭线程池</span></span><br><span class="line">threadPool.shutdownNow();</span><br><span class="line"></span><br><span class="line"><span class="comment">//用线程池启动定时器，每隔20秒执行一次任务</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">3</span>).scheudle(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">20</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h4 id="Callable-与-Runnable"><a href="#Callable-与-Runnable" class="headerlink" title="Callable 与 Runnable"></a>Callable 与 Runnable</h4><p>java.lang.Runnable ，是一个接口，声明一个run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于run()方法返回值为void类型，<strong>so在执行完任务之后无法返回任何结果</strong>。</p>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面声明了一个方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exceptions</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个泛型接口，声明一个call方法，<strong>同时这个方法可以有返回值V，返回的类型就是传递进来的V类型</strong>，当然也可以抛出异常；</p>
<p>如何使用Callable? 一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明若干个submit方法的重载版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个实现Callable接口的任务，并且返回了封装了异步计算结果的Future</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; taks)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task,T result)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future 就是对于具体的Runnable或者Callable任务的<strong>执行结果</strong> 相关操作：进行取消，查询是否完成，获取结果。</p>
<p>可以通过<strong>get()方法</strong>获取执行结果，<strong>该get()方法会阻塞直到任务返回结果</strong></p>
<p>Future<V> 接口是用来获取异步计算结果的，说白了就是对具体的Runnable或Callable对象任务执行的结果</p>
<p>进行获取（<strong>get()</strong> ) , 取消（<strong>cancel()</strong>）,判断是否完成等操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//取消任务，如果取消任务成功返会true，如果取消任务失败返回false；</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interrupt：表示取消正在执行却没有执行完毕的任务，</span></span><br><span class="line"><span class="comment">     * true: 可以取消正在执行过程中的任务，</span></span><br><span class="line"><span class="comment">     * false:</span></span><br><span class="line"><span class="comment">     * 1.如果任务已经完成，interrupt =true or false，方法返回false，无法取消已经完成的任务，</span></span><br><span class="line"><span class="comment">     * 2.如果任务正在执行，interrupt=true 方法返回true，interrupt=false，方法返回false</span></span><br><span class="line"><span class="comment">     * 3.如果任务还没执行，interrupt=true or false， 方法返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> interrupt)</span></span>;</span><br><span class="line">    <span class="comment">//表示任务是否被取消成功，如果在任务正常完成前被取消成功，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//表示任务是否已经完成，完成返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取执行结果，会阻塞，会一直等到任务执行完毕之后才返回</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedExecption,ExecutionException</span>;</span><br><span class="line">    <span class="comment">//获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Future提供三种功能：</p>
<ul>
<li>判断任务是否完成；</li>
<li>能够中断任务；</li>
<li>能够获取任务执行结果；</li>
</ul>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>FutureTask类实现了RunnableFuture接口，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>,<span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口，所以其可以被当作Runnable被线程执行，也可以作为Future得到Callable的返回值；</p>
<p><strong>执行状态</strong></p>
<ul>
<li>未启动，FutureTask.run() 方法还没有被执行之前，处于未启动状态，创建一个FutureTask，并没有调用run()方法；</li>
<li>已启动，FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态</li>
<li>已完成，FutureTask.run()<strong>方法执行完正常结束，或者被取消，或者抛出异常结束</strong>，FutureTask处于已完成状态</li>
</ul>
<p><img src="https://i.loli.net/2020/05/03/OqIfesop9PyTShr.png" alt=""></p>
<p>FutureTask方法执行示意图：</p>
<p><img src="https://i.loli.net/2020/05/03/KsGxZ7n1wNmBFlc.png" alt=""></p>
<ul>
<li>当FutureTask处于未启动或者已启动状态时，如果此时调用FutureTask.get() 方法将导致调用线程阻塞</li>
<li>当FutureTask处于已完成时，执行FutureTask.get()方法导致调用线程立即返回结果，或者抛出异常</li>
</ul>
<p><img src="https://i.loli.net/2020/05/03/gUSpC1FNZLIozBR.png" alt=""></p>
<ul>
<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将会导致此任务永远不会执行，</li>
<li>当FutureTask处于已启动状态时，执行FutureTask.cancel()方法，如果是cancel(true)将以中断执行此任务线程的方式来试图停止任务，如果取消成功，cancel()返回true，表示任务取消成功，cancel(false)对正在执行的任务线程不产生影响，cancel() 返回false；</li>
<li>当FutureTask处于已完成状态时，执行cancel()返回false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FutureTask&lt;Callable&lt;V&gt; callable)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable,V result)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask 是Future接口的一个唯一实现类；</p>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>使用Callable，Future，FutureTask最大的好处就是，通过这种方式创建线程， <strong>能够返回结果</strong>；</p>
<p>场景：计算一个数据，而这个数据的计算比较耗时，后面的程序需要使用到这个数据结果。</p>
<p>​            考虑Thread，Callable ；Callable是有返回值的，首选；</p>
<p>​             开启一个线程去计算，主线程继续做其他的事，后面需要使用到这个数据，使用Future获取就可以了。</p>
<ul>
<li><p><strong>使用Callable + Future获取执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算结果中...."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);<span class="comment">//模拟耗时操作</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    ExecutorService executor= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//创建Callable对象任务</span></span><br><span class="line">    Task task =<span class="keyword">new</span> Task();</span><br><span class="line">    <span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">    Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行结果为："</span>+result.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"未获取到结果"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">实验结果</span><br><span class="line">--------</span><br><span class="line">计算结果中....</span><br><span class="line">主线程执行</span><br><span class="line">执行结果为：<span class="number">499500</span></span><br><span class="line">任务执行完毕</span><br><span class="line">--------</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用Callable+FutureTask获取执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算结果中...."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);<span class="comment">//模拟耗时操作</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    ExecutorService executor = Executors.newCacheThreadPool();</span><br><span class="line">    Task task =<span class="keyword">new</span> Task();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">    <span class="comment">//FutureTask 作为 Future 加入到线程池中</span></span><br><span class="line">    executor.submit(futureTask);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    <span class="comment">//Task task =new Task();</span></span><br><span class="line">    <span class="comment">//FutureTask&lt;Integer&gt; futureTask =new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line">    <span class="comment">//FutureTask 作为 Runnable 加入到线程中</span></span><br><span class="line">    <span class="comment">//Thread thread =new Thread(futureTask);</span></span><br><span class="line">    <span class="comment">//thread.start();</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        	System.out.println(<span class="string">"futureTask 执行结果为："</span>+futureTask.get());   </span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"futureTask.get()未获取到结果"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">----</span><br><span class="line">计算结果中....</span><br><span class="line">主线程执行</span><br><span class="line">futureTask 执行结果为： <span class="number">499500</span></span><br><span class="line">所有任务执行完毕    </span><br><span class="line">----</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <strong>实现Runnable接口和实现Callable接口的区别</strong></p>
<ul>
<li>Runnable自从jdk1.1就有了，Callable是1.5之后有的</li>
<li>Callable规定的方法是call(), Runnable规定的方法是run();</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是无返回值的；</li>
<li>call方法可以抛出异常，run方法不能</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步执行计算的结果，在这个过程中，会检查计算是否完成，等待（阻塞手段）计算的完成，并获取计算的结果。因此通过Future对象可以了解任务的执行过程，可取消任务的执行，还可以获取执行的结果</li>
<li>加入到线程池运行，Runnable使用ExecutorService的execute方法，而Callable使用的是submit提交。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/" data-id="ck9sievty0003ls3b1nrb6ava" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(四) ThreadPoolExecutor线程池各参数意义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/">Java多线程（四）ThreadPoolExecutor相关知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>为什么用使用线程池?</strong></p>
<p>耗时操作放到后台线程去执行；（网络，本地文件，数据库）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>那么某个时间点，迅速开启很多线程（加载列表图片，然后用户滑动列表）</p>
<p>问题：内存使用量飙升，thread占用内存，线程分配内存，工作，工作完成，释放内存，内存变化为开始没有分配，低占用内存, 分配内存给线程进行工作，高占用内存，线程完成任务，释放内存，低占用内存；</p>
<ul>
<li>内存抖动：短时间开启了很多线程，完成任务，线程都被回收，内存表现为低-高-低， 甚至可能会出现OOM</li>
<li>一个系统所能处理的线程数量是有限的，如果超过了最大承载量，性能会受到很大影响，而且还可能会影响用户后续操作；</li>
</ul>
<p>那么这个时候ThreadPool线程池的作用体现出来了。</p>
<p><strong>ThreadPoolExecutor详解</strong></p>
<p>Java提供的操作线程池的API：ThreadPoolExecutor 该类是实现了ExecutorService接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@corePoolSize</span>: 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maximumPoolSize</span>: 线程池允许最大的线程数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@keepAliveTime</span>: 当线程空闲时间达到了keepAliveTime，该线程会退出，直到线程数量等于了			corePoolSize，如果想要线程池中的所有线程数量为0，那么可以设置allowCoreThreadTimeOut=true，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@allowCoreThreadTimeOut</span>: 是否允许核心线程池线程经历了空闲时间keepAliveTime退出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@workQueue</span>:任务队列，pool.execute(runnable)提交的任务Task都会放在workQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPoolExecutor pool =<span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                                               <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                                               <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                                               TimeUnit unit,</span><br><span class="line">                                               BlockingQueue&lt;Runnable&gt; workQueue);</span><br></pre></td></tr></table></figure>

<h4 id="自定义一个ThreadPoolExecutor"><a href="#自定义一个ThreadPoolExecutor" class="headerlink" title="自定义一个ThreadPoolExecutor"></a>自定义一个ThreadPoolExecutor</h4><p>使用有界队列，和自定义ThreadFactory和拒绝策略的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize =<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime=<span class="number">10</span>;</span><br><span class="line">    TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">    BlockQueue&lt;Runnable&gt; workQueue= <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>);</span><br><span class="line">    ThreadFactory thredFactory = <span class="keyword">new</span> CustomThreadFactory();</span><br><span class="line">    RejectExecutionHandler handler =<span class="keyword">new</span> IgnorePolicy();</span><br><span class="line">    ThreadPoolExecutor executor =<span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">                                                       maximumPoolSize,</span><br><span class="line">                                                       keepAliveTime,</span><br><span class="line">                                                       unit,</span><br><span class="line">                                                       workQueue,</span><br><span class="line">                                                       threadFactory,</span><br><span class="line">                                                        handler</span><br><span class="line">                                                       );</span><br><span class="line">    executor.prestartAllCoreThreads(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        MyTask taks =<span class="keyword">new</span> MyTask(String.valueOf(i));</span><br><span class="line">        executor.execute(tasks);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNum = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r, <span class="string">"Thead-pool-"</span> + threadNum.getAndIncrement());</span><br><span class="line">            System.out.println(t.getName() + <span class="string">" has been created"</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IgnorePolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            System.err.println(r.toString() + <span class="string">" rejected"</span> +<span class="string">" remove the runnable :"</span>+ executor.remove(r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is Running"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"MyTask [Thread-pool-"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实验结果</span><br><span class="line">-----</span><br><span class="line">Thead-pool-<span class="number">1</span> has been created</span><br><span class="line">Thead-pool-<span class="number">2</span> has been created</span><br><span class="line">Thead-pool-<span class="number">3</span> has been created</span><br><span class="line">MyTask [Thread-pool-<span class="number">1</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">2</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">3</span>] is Running</span><br><span class="line">Thead-pool-<span class="number">4</span> has been created</span><br><span class="line">MyTask [Thread-pool-<span class="number">7</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">8</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">6</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">9</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">10</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">4</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">5</span>] is Running     </span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>核心线程数为2，最大线程数为4，队列大小为2，任务数为10；</p>
<p>开启两个线程<strong>Thread-pool-1</strong>和<strong>Thread-pool-2</strong>执行任务<strong>MyTask</strong> [Thread-pool-1] 和 <strong>MyTask</strong> [Thread-pool-2]，</p>
<p>此时线程数为2，但是任务提交没有结束，此时任务<strong>MyTask</strong> [Thread-pool-3]</p>
<p>和<strong>MyTask</strong> [Thread-pool-6]发现核心线程数已经满了，则此时会加入到队列中进行等待，等待队列</p>
<p>大小为2，此时加入到的3和6的任务已经将队列占满了，这个时候线程池就会创建线程<strong>Thread-pool-3</strong>和<strong>Thread-pool-4</strong>来执行了任务<strong>MyTask</strong> [Thread-pool-3]和<strong>MyTask</strong> [Thread-pool-6]，执行完了，任务<strong>MyTask</strong> [Thread-pool-4]和<strong>MyTask</strong> [Thread-pool-5]进入队列，填充队列；</p>
<p>此时创建的线程数为4等于大于最大线程数，并且当前（<strong>MyTask</strong> [Thread-pool-4]和<strong>MyTask</strong> [Thread-pool-5]进行填充）的队列已经满了，就会拒绝其他任务<strong>MyTask</strong> [Thread-pool-7]，<strong>MyTask</strong> [Thread-pool-8]，<strong>MyTask</strong> [Thread-pool-9]，<strong>MyTask</strong> [Thread-pool-10]；</p>
<p>这个时候执行了任务<strong>MyTask</strong> [Thread-pool-4]和<strong>MyTask</strong> [Thread-pool-5]，执行完毕之后，队列清空；</p>
<p>总结：最大线程数加上队列大小，以及任务数可以推算出是否任务会不会拒绝</p>
<p>​            如果最大线程数+队列大小&lt;任务数，拒绝的任务个数为任务数-(最大线程数+)</p>
<p><img src="https://i.loli.net/2020/05/04/aZYztnQC3Psw5eD.png" alt="截屏2020-05-04 13.41.37.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/" data-id="ck9sievu00006ls3b34hual4q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(二) 同步线程分组问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-05-03T03:34:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98/">Java多线程（二）同步线程分组问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统的线程同步可以通过同步代码块或者同步方法实现；</p>
<p>如何实现同步，就需要借助一个同步监视器来完成；</p>
<p>要想确保线程之间能够同步，那么监视器对象对于同步线程之间就是同一个对象，</p>
<p>这样才会起到同步互斥效果。</p>
<p>单组同步函数：使用字节码（class）作为同步对象，是因为在内存中只存在一份某个类的字节码，</p>
<p>多组同步函数：就需要使用多个同步监视器对象，如果同步监视器使用同一个类的字节码，那么这样的话就成了一组同步函数；</p>
<p>来看以下实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     String source = <span class="string">"abc"</span>;</span><br><span class="line">     <span class="keyword">char</span>[] cs = source.toCharArray();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"--------------&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cs.length; j++) &#123;</span><br><span class="line">           System.err.println(cs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">    System.err.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"------------&gt;"</span>);</span><br><span class="line">        System.err.println(<span class="string">"the index is :"</span> + (i + <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">     System.err.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-1"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-2"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-3"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-4"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实验结果</span><br><span class="line">-------</span><br><span class="line"> &lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">4</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------Thread end---------&gt;   </span><br><span class="line">    </span><br><span class="line">-------</span><br></pre></td></tr></table></figure>

<p>由上述代码分析可知，执行结果，还是依次执行，说明Thread-1拿到锁，执行完毕，释放锁，这个时候Thread-2拿到锁，执行，释放，Thread-3拿到锁，执行，释放，Thread-4拿到锁，执行，释放，程序结束。</p>
<p>没有按照我们预想，print 和 printName 方法没有交替执行，也就是说他们对应的相应的同步监视器应该是同一个对象。</p>
<p>print方法和pritnName方法都是static的，而且又都是synchronized关键字修饰的，所以同步监视器对象都是当前类的字节码对象；</p>
<p>当一个线程执行了print或者printName方法，其他3个线程只有等该线程执行完毕之后才能接着执行；</p>
<p>按照多组函数同步的概念，一组的同步不应该影响其他组的执行；</p>
<p>改造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     String source = <span class="string">"abc"</span>;</span><br><span class="line">     <span class="keyword">char</span>[] cs = source.toCharArray();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"--------------&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cs.length; j++) &#123;</span><br><span class="line">           System.err.println(cs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">    System.err.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造一下printName方法，使其同步监视器对象为String的字节码对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(String<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"------------&gt;"</span>);</span><br><span class="line">        System.err.println(<span class="string">"the index is :"</span> + (i + <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">     System.err.println();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-1"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-2"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-3"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-4"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实验结果</span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">3</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">4</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">5</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">6</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">7</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">8</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">9</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">10</span></span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">4</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">3</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">4</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">5</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">6</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">7</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">8</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">9</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">10</span></span><br><span class="line">------Thread end---------&gt;</span><br><span class="line">    </span><br><span class="line">-------</span><br></pre></td></tr></table></figure>

<p>可以看出实验结果：Thread-1 执行完毕，Thread-3执行，然后在Thread-2执行，最后Thead-4执行，如此交替执行。</p>
<p>由此可以得出，同步线程分组的关键就是使用不同的同步监视器对象进行同步互斥；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98/" data-id="ck9sievu10009ls3b4yg3e41j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(一) 线程间的互斥和同步通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/" class="article-date">
  <time datetime="2020-05-02T13:56:35.000Z" itemprop="datePublished">2020-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/">Java多线程（一） 线程间的互斥和同步通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Thread-线程"><a href="#Thread-线程" class="headerlink" title="Thread 线程"></a>Thread 线程</h3><p>Java 语言用Thread来描述一个线程，通过Thread类的start方法来开启一个线程</p>
<p><strong>run方法的源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//target 实则为Runnable接口，用来表示具体执行的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建线程的两种传统方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//method 1;</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//method 2;</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>Thread的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>&#123;</span><br><span class="line">    <span class="comment">//Initializes a Thread</span></span><br><span class="line">    init(<span class="keyword">null</span>,target,<span class="string">"Thread-"</span>+nextThreadNum(),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g,Runnable target,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> stackSize,AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> inheritThreadLocals)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码..</span></span><br><span class="line">    <span class="keyword">this</span>.target =target;</span><br><span class="line">    <span class="comment">//省略其他代码..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        target.run();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从init()方法中可以看到，其中一行代码就是对target（Runnable类型）赋值</p>
<p>因为线程所执行的任务都在run()方法里面，那么在run里面，target就不为null，然后调用Runnable的run方法；</p>
<p>因为重写了Runnable的run方法，最终会执行我们覆写的run方法执行相关任务；</p>
<p>TODO ：如果同时实现了Thread的run方法，又同时覆盖了Runnable的run方法，执行先后顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">"Thread run start\n"</span>);</span><br><span class="line">                <span class="keyword">super</span>.run();</span><br><span class="line">                System.err.println(<span class="string">"Thread run end\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"myRunnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">Thread run start</span><br><span class="line">myRunnable</span><br><span class="line">Thread run end</span><br><span class="line">------------------</span><br></pre></td></tr></table></figure>

<p>说明了执行了Thread的run方法，然后在自定义Runnable的run方法；</p>
<h3 id="传统定时器"><a href="#传统定时器" class="headerlink" title="传统定时器"></a>传统定时器</h3><p>定时器通过Timer这个类来描述，通过schedule方法来调度，定时执行的任务通过TimerTask来定义；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">MyTimerTask timerTask = <span class="keyword">new</span> MyTimerTask();</span><br><span class="line">timer.schedule(timerTask, <span class="number">2000</span>,<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MyTimerTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.err.println(<span class="string">"timer task run _"</span> + <span class="keyword">new</span> Date().getTime());</span><br><span class="line">            count = (count + <span class="number">1</span>) % <span class="number">2</span>; <span class="comment">// 保证0 和 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程之间的互斥和同步"><a href="#线程之间的互斥和同步" class="headerlink" title="线程之间的互斥和同步"></a>线程之间的互斥和同步</h3><p>当两个线程去同时操作一个字符串，就可能出现线程安全问题，</p>
<p>那么只要保证：当只有第一个线程执行完毕之后，第二个线程才能执行的方式，这就涉及到互斥的概念，亦同步</p>
<ul>
<li>同步代码块</li>
<li>同步方法</li>
</ul>
<p><code>Synchronized</code> 同步监视器</p>
<p><strong>Synchronized的作用域：</strong></p>
<ul>
<li><p>作用在代码块上：只是锁定了该代码块，代码块外面的代码还是可以被访问的，如果想要达到作用在成员方法的效果，可以锁定this引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> synchronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">		.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>作用在成员方法上：某一时刻只能有一个线程执行该Synchronized方法</li>
</ul>
<ul>
<li>作用在静态方法上—–&gt;同步锁就是方法所在类的class对象，并不是synchronized方法所在的对象，意味着一旦被调用，该线程锁定的是synchronized方法所在对象的Class对象，其他线程无法调用该方法。直到该方法执行完之后释放了锁，其他线程才有可能调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 synchronized 锁定static 方法 锁class --- 》类锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 synchronized 锁定成员方法 锁定的是对象 ----》对象锁 方法锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3 synchronized 作用在代码块上, 锁定的是代码块</span></span><br></pre></td></tr></table></figure>



<p><strong>修饰代码块 多线程调用同一个对象的同步方法会阻塞，调用不同的对象的同步方法不会阻塞</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"print1-1"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"print1-2"</span>)&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"thread-name-1"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"thread-name-2"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String lock =<span class="keyword">new</span> String(<span class="string">"lock"</span>);<span class="comment">///在方法体内，调用一次就实例化一次，多线程访问不会阻塞，因为不是同一个对象，锁是不同的</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i--&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// this 关键字 会阻塞</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i--&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"><span class="comment">//不阻塞</span></span><br><span class="line">print1-<span class="number">1</span> : <span class="number">5</span></span><br><span class="line">print1-<span class="number">2</span> : <span class="number">5</span></span><br><span class="line">print1-<span class="number">1</span> : <span class="number">4</span></span><br><span class="line">print1-<span class="number">2</span> : <span class="number">4</span></span><br><span class="line">print1-<span class="number">1</span> : <span class="number">3</span></span><br><span class="line">print1-<span class="number">2</span> : <span class="number">3</span></span><br><span class="line">print1-<span class="number">1</span> : <span class="number">2</span></span><br><span class="line">print1-<span class="number">2</span> : <span class="number">2</span></span><br><span class="line">print1-<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">print1-<span class="number">2</span> : <span class="number">1</span></span><br><span class="line">print1-<span class="number">2</span> : <span class="number">0</span></span><br><span class="line">print1-<span class="number">1</span> : <span class="number">0</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//阻塞</span></span><br><span class="line">thread-name-<span class="number">1</span> : <span class="number">5</span></span><br><span class="line">thread-name-<span class="number">1</span> : <span class="number">4</span></span><br><span class="line">thread-name-<span class="number">1</span> : <span class="number">3</span></span><br><span class="line">thread-name-<span class="number">1</span> : <span class="number">2</span></span><br><span class="line">thread-name-<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">thread-name-<span class="number">1</span> : <span class="number">0</span></span><br><span class="line">thread-name-<span class="number">2</span> : <span class="number">5</span></span><br><span class="line">thread-name-<span class="number">2</span> : <span class="number">4</span></span><br><span class="line">thread-name-<span class="number">2</span> : <span class="number">3</span></span><br><span class="line">thread-name-<span class="number">2</span> : <span class="number">2</span></span><br><span class="line">thread-name-<span class="number">2</span> : <span class="number">1</span></span><br><span class="line">thread-name-<span class="number">2</span> : <span class="number">0</span></span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<h3 id="线程之间的同步通信"><a href="#线程之间的同步通信" class="headerlink" title="线程之间的同步通信"></a>线程之间的同步通信</h3><p><strong>子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，再回到主线程又循环100次，如此循环50次</strong></p>
<p>分析可知： 50次，主100，子10 ，双重循环，伪伪码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k =<span class="number">50</span>;</span><br><span class="line">    <span class="comment">//child thread</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"child thread"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">                    System.err.println(<span class="string">"child thread seq"</span>+j+<span class="string">" loop at the times of "</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main thread </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">			System.err.println(<span class="string">"main thread seq:"</span>+j+<span class="string">" loop at the times of "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述代码可知，执行次序是乱的，子线程执行10次是会被打断的，主线程执行100次也是被打断的；</p>
<p>自然想到同步，同步加在哪里呢？</p>
<p>锁谁—》方法，类，对象。</p>
<p>此时使用class作为同步监视器不好，如果程序逻辑比较复杂，需要多组互斥，不妨将共同的数据（同步锁）或共同的算法（比如这里的主子线程的循环）抽离到一个类中;</p>
<p>因此可以改造抽离代码为如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.err.println(<span class="string">"child thread seq:"</span>+i+<span class="string">" loop at the times of "</span>+k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.err.println(<span class="string">"main thread seq:"</span>+i+<span class="string">" loop at the times of "</span>+k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用wait 和 notify 关键字来完成线程之间的通信</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> isChildHandle=<span class="keyword">true</span>; <span class="comment">//默认子线程执行</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isChildHandle)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait(); <span class="comment">//如果当前不是子线程操作，等待 下列代码就不会执行了</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">   </span><br><span class="line">        &#125;</span><br><span class="line">        isChildHandle =<span class="keyword">false</span>; <span class="comment">//子线程处理完毕，重置标志位</span></span><br><span class="line">        <span class="keyword">this</span>.notify(); <span class="comment">//唤醒主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isChildHandle)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++)&#123;</span><br><span class="line">                  System.out.println(<span class="string">"main thread seq:"</span>+i+<span class="string">"  loop at the times of "</span>+k);</span><br><span class="line">        &#125;</span><br><span class="line">        isChildHandle=<span class="keyword">true</span>; <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Business business =<span class="keyword">new</span> Business();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"ChildThread"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">                business.child(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        business.main(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">child thread seq:<span class="number">1</span>  loop at the times of <span class="number">1</span></span><br><span class="line">child thread seq:<span class="number">2</span>  loop at the times of <span class="number">1</span></span><br><span class="line">child thread seq:<span class="number">3</span>  loop at the times of <span class="number">1</span></span><br><span class="line">child thread seq:<span class="number">4</span>  loop at the times of <span class="number">1</span></span><br><span class="line">child thread seq:<span class="number">5</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">1</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">2</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">3</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">4</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">5</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">6</span>  loop at the times of <span class="number">1</span></span><br><span class="line">main thread seq:<span class="number">7</span>  loop at the times of <span class="number">1</span></span><br><span class="line">child thread seq:<span class="number">1</span>  loop at the times of <span class="number">2</span></span><br><span class="line">child thread seq:<span class="number">2</span>  loop at the times of <span class="number">2</span></span><br><span class="line">child thread seq:<span class="number">3</span>  loop at the times of <span class="number">2</span></span><br><span class="line">child thread seq:<span class="number">4</span>  loop at the times of <span class="number">2</span></span><br><span class="line">child thread seq:<span class="number">5</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">1</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">2</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">3</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">4</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">5</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">6</span>  loop at the times of <span class="number">2</span></span><br><span class="line">main thread seq:<span class="number">7</span>  loop at the times of <span class="number">2</span></span><br><span class="line">    .....</span><br><span class="line">-------</span><br></pre></td></tr></table></figure>



<h3 id="线程范围内共享数据-ThreadLocal"><a href="#线程范围内共享数据-ThreadLocal" class="headerlink" title="线程范围内共享数据(ThreadLocal)"></a>线程范围内共享数据(ThreadLocal)</h3><p><strong>效果</strong>：假设线程0给i赋值为1，当线程0取的时候也是1，也就是说线程之间取各自的放进去的值；这就是需要线程范围内的数据共享；</p>
<p>定义一个Map集合key 和 value 分别为Thread 和 Integer;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">map.put(Thread.currentThread(),k)</span><br></pre></td></tr></table></figure>

<p>那么可以通过map根据当前线程为key 值来取数据；</p>
<p>这有什么用呢，比如事务，所谓事务回滚和提交都是指的是在一个线程上的，如果在不同的线程上则会逻辑混乱，因此很有必要在线程范围内进行数据共享，把数据绑定到该线程上，然后根据该线程获取的数据也就是同一个数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadShareData</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ThreadShareData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//主要是使用ThreadLocal将数据与Thread进行绑定</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;ThreadShareData&gt; local = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadShareData <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ThreadShareData threadShareData = local.get();</span><br><span class="line">            <span class="keyword">if</span> (threadShareData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                threadShareData = <span class="keyword">new</span> ThreadShareData();</span><br><span class="line">                local.set(threadShareData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> threadShareData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试模块A  模拟从线程中取值</span></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ThreadShareData instance = ThreadShareData.getInstance();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A from "</span> + Thread.currentThread().getName() + <span class="string">" get value:"</span> + instance.getName()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试模块B 模拟从线程中取值</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		ThreadShareData instance = ThreadShareData.getInstance();</span><br><span class="line"> 		System.out.println(<span class="string">"B from "</span> +Thread.currentThread().getName() + <span class="string">" get value:"</span> + instance.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//多线程</span></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> k = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">                    ThreadShareData.getInstance().setName(<span class="string">"name:"</span> + k);</span><br><span class="line">                    ThreadShareData.getInstance().setAge(k);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>); <span class="comment">//模仿线程竞争</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印多线程分配的数据</span></span><br><span class="line">                    System.err.println(Thread.currentThread().getName() + <span class="string">" put value :"</span> + k);</span><br><span class="line">                    <span class="keyword">new</span> A().get();</span><br><span class="line">                    <span class="keyword">new</span> B().get();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Thread-<span class="number">0</span> put value :<span class="number">644699847</span></span><br><span class="line">Thread-<span class="number">1</span> put value :<span class="number">2007036017</span></span><br><span class="line">A from Thread-<span class="number">1</span> get value:name:<span class="number">2007036017</span></span><br><span class="line">A from Thread-<span class="number">0</span> get value:name:<span class="number">644699847</span></span><br><span class="line">B from Thread-<span class="number">0</span> get value:name:<span class="number">644699847</span></span><br><span class="line">B from Thread-<span class="number">1</span> get value:name:<span class="number">2007036017</span></span><br><span class="line">----</span><br><span class="line">总结：A 和 B 取出对应的线程分配的数据</span><br><span class="line">内存溢出？ 当一个线程死亡，系统就会把该线程在ThreadLocal产生的数据清除掉；</span><br></pre></td></tr></table></figure>

<h3 id="多个线程访问共享对象和数据的方式"><a href="#多个线程访问共享对象和数据的方式" class="headerlink" title="多个线程访问共享对象和数据的方式"></a>多个线程访问共享对象和数据的方式</h3><p>概念：如果每个线程执行的代码相同，可以使用相同的Runnable对象，这个Runnable对象中有那个共享数据；</p>
<p>买票系统，票数是共享的，100 张 递减，一张张卖，Runnable执行卖票操作（票数递减），多个线程表示多个窗口执行卖票操作；</p>
<p>未在Runnable中的run方法进行synchronized锁住代码块，具体如下看实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个Runnable方法用于描述售票过程</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123; <span class="comment">//方法锁 其实和锁代码块效果一样</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                if (count &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//                    count--;</span></span><br><span class="line"><span class="comment">//                    System.err.println(Thread.currentThread().getName() + "正在卖票：还剩下：" + count + "张票");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                    System.err.println("票已经卖完了");</span></span><br><span class="line"><span class="comment">//                    return;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count--;</span><br><span class="line">                System.err.println(Thread.currentThread().getName() + <span class="string">"正在卖票：还剩下："</span> + count + <span class="string">"张票"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">"票已经卖完了"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//未在run方法中进行synchronized锁住代码块</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//切换时间片，降低CPU使用率，让其他线程进行执行，当前线程休眠之后，会自动苏醒，并切换到可运行状态（就绪状态），并不是运行状态，等待下一次CPU的时间片到来。</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyRunnable runable =<span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(runable,<span class="string">"窗口"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">模拟实验</span><br><span class="line">---------</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">3</span>正在卖票：还剩下：<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">2</span>正在卖票：还剩下：<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>正在卖票：还剩下：<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">3</span>正在卖票：还剩下：<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">2</span>正在卖票：还剩下：<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">1</span>正在卖票：还剩下：<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">3</span>正在卖票：还剩下：<span class="number">1</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">0</span>张票</span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<p>在Runnable中的run方法使用synchronized锁住代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个Runnable方法用于描述售票过程</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object(); <span class="comment">//对象锁</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123; <span class="comment">//方便实验效果，该售卖方法不进行加锁操作</span></span><br><span class="line">		<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           count--;</span><br><span class="line">           System.err.println(Thread.currentThread().getName() + <span class="string">"正在卖票：还剩下："</span> + count + <span class="string">"张票"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"票已经卖完了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在run方法中进行synchronized锁住代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            	sellTicket();</span><br><span class="line">            	<span class="keyword">try</span>&#123;</span><br><span class="line">           		    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">           		 &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">            	&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    MyRunnable runable =<span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(runable,<span class="string">"窗口"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实验结果： run方法中加入代码，只有一个thread执行了售卖操作，因为在该run方法中加入了<span class="keyword">synchronized</span>关键字，此时获取到锁的thread不会释放锁，其他线程只能无法获取锁，进行代码执行。</span><br><span class="line">----</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">1</span>张票</span><br><span class="line">窗口<span class="number">0</span>正在卖票：还剩下：<span class="number">0</span>张票    </span><br><span class="line">----</span><br></pre></td></tr></table></figure>

<p>总结：因此我们可以将同步互斥的方法，或者变量放在同一个类，那么实例中count 就是我们需要去同步的变量，那么执行卖票的方法sellTicket方法，就需要进行一定的加锁操作，通过外界创建的线程，来依次调用调用同步方法，来更改同步变量，处理好了同步互斥的关系，那么各个线程之间就可以同步通信了，也就是这个时候thread1 当前卖票还剩29，那么下一个线程在执行卖票的时候，会去参考当前的count为29，在此基础上进行递减，这也就是多线程间实现同步通信的实质，互斥是一种手段，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/02/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%20%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/" data-id="ck9sievu00005ls3b8ioiafy6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/02/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2020-05-02T13:46:35.000Z" itemprop="datePublished">2020-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/02/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/">线程进程概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###线程 进程 概念</p>
<p>@来自 <a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384</a></p>
<p><strong>进程和线程都是一个时间段的描述，是CPU工作时间的描述；</strong></p>
<p>CPU+RAM+各种资源（显卡，光驱，键盘，GPS等外设）构成电脑，</p>
<p>电脑运行，实际上就是CPU和相关寄存器以及RAM之间的事；</p>
<p><strong>基础事实</strong></p>
<p>CPU太快，寄存器执行效率仅能追上其脚步，RAM和其他的IO设备更是效率低下。</p>
<p>当多个任务要执行怎么办？ 轮流来？优先级高的来？无论是哪种策略，一句话获取到了CPU的时间片。</p>
<p><strong>必知事实</strong></p>
<p>执行一段程序代码，当得到CPU的时候，相关的资源必须到位，就是显卡，GPU的，然后CPU开始执行，除了CPU以外的所有构成了这个程序的执行环境，也就是我们定义的<strong>程序上下文</strong>，当程序执行完了或者是分配给他的执行时间用完了，就会被切换出去，在被切换出去的最后一步就是保存程序上下文，因为这是被CPU执行的运行环境。</p>
<p><strong>串联事实</strong></p>
<p>CPU看起来所有的任务都是一个一个的轮流执行的，具体的轮流方式就是：先加载程序A的上下文，然后执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B，保存程序B的上下文。</p>
<p><strong>定义</strong></p>
<p>进程是资源（CPU，内存）分配的基本单位，具有一定功能的程序关于数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）线程基本上不拥有系统资源，但是其拥有运行过程中必不可少的资源（程序计数器，栈）</p>
<img src="https://i.loli.net/2020/05/02/judtDcJC9MbxEk7.png" style="zoom:57%;" />

<p>​                            进程的地址空间</p>
<p>其中.data是已经初始化的全局和静态变量</p>
<p>.bss是未初始化的全局和静态变量</p>
<p>.text是已经编译的程序机器代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">0</span>;<span class="comment">//全局初始化区----&gt;.data</span></span><br><span class="line"><span class="keyword">char</span>* p1; <span class="comment">//全局未初始化区 ---&gt;.data</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[]=<span class="string">"abc"</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span>* p3=<span class="string">"1235"</span>;<span class="comment">//1235\0在常量区，p3在栈上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">    p1=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//分配得来的10和20字节的区域就在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">"1234"</span>);<span class="comment">//1234\0放在常量区，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<p>进程是资源分配的基本单位，线程是程序执行的基本单位</p>
<p>进程拥有自己的资源空间，每启动一个进程，系统就会为它分配地址空间，而线程与CPU资源分配无关，多个线程共享同一进程内的资源，各线程地址空间相互独立；</p>
<p>一个进程包含若干个线程；</p>
<p><strong>优劣</strong></p>
<p>1.线程之间通信更方便，同一进程下的线程共享全局变量，静态变量等数据，而进程之间的通信需要通过IPC进行；</p>
<p>2.线程调度与切换比进程快很多，同时创建一个线程的开销比进程要小很多；</p>
<p>3.多进程程序更加健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉，并不会对另外一个进程造成影响，因为进程有自己独立的地址空间；</p>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>@<a href="https://www.cnblogs.com/marsitman/p/11228684.html" target="_blank" rel="noopener">https://www.cnblogs.com/marsitman/p/11228684.html</a></p>
<p>生命周期包含5个阶段：新建，就绪，运行，阻塞，销毁</p>
<ul>
<li><p>新建：new方法， – new Thread();</p>
</li>
<li><p>就绪：调用start()方法，这时候线程处于等待CPU分配资源的阶段，谁先抢到CPU资源，谁先开始；</p>
</li>
<li><p>运行：当就绪的线程被调度并获得CPU资源时候，便进入运行状态，run方法定义了线程的操作和功能</p>
</li>
<li><p>阻塞：在运行状态的时候，可能由于某些原因导致运行状态变成了阻塞状态，比如sleep(), wait()之后线程处于阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify/notifyAll方法，唤醒的线程不会立即执行run方法，而是<strong>再次等待CPU分配资源进入运行状态。</strong></p>
</li>
<li><p>销毁：如果线程正常执行完毕后或者线程被提前强制性的终止或者出现异常导致结束，线程就要被销毁，释放资源；</p>
<p><img src="https://i.loli.net/2020/05/03/UbHchVonMB7vKkC.png" alt=""></p>
</li>
</ul>
<p><strong>新建状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t =<span class="keyword">new</span> Thread();</span><br></pre></td></tr></table></figure>

<p>这里的创建，仅仅是Java的语言层面的创建，操作系统层面，真正的线程还没被创建，</p>
<p>只有调用了start() 方法之后，该线程才会被创建出来，进入到Runnable状态，</p>
<p><img src="https://i.loli.net/2020/05/03/HtGEMVPBTzgY4Kk.png" alt=""></p>
<p><strong>就绪状态</strong></p>
<p>调用start() 方法后，JVM进程会去创建一个新的线程，而此线程不会马上被CPU调度，进入Running状态，这里会有一个中间状态，就是Runnable状态，可以理解为等待被CPU调度的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/03/QuFvyiIzU53D8CV.png" alt=""></p>
<p>那么处于Runnable状态的线程能发生哪些状态转变？</p>
<p><img src="https://i.loli.net/2020/05/03/Eu81troqgw9aBhp.png" alt=""></p>
<p>Runnable状态的线程是无法直接进入Blocked状态和Terminated状态的，只有处于Running状态的线程（获得CPU调度执行权的线程才有资格进入到Blocked和Terminated状态，Runnabled状态的线程要么被切换为Running状态，要么被意外终止）</p>
<p><strong>运行状态</strong></p>
<p>当CPU调度发生了，并从任务队列中选中了某个Runnable线程时，该线程会进入Running执行状态，并且开始调用run()方法执行任务，那么处于Running状态的线程能发生哪些状态转变？</p>
<ul>
<li><p>被转换为Terminated状态，比如调用stop()方法</p>
</li>
<li><p>被转换为Blocked状态，</p>
<ul>
<li>比如调用了sleep，wait方法加入到waitSet中；</li>
<li>比如进行IO阻塞操作，查询数据库进入阻塞状态</li>
<li>获取某个锁的释放，而被加入该锁的阻塞队列中；</li>
</ul>
</li>
<li><p>该线程的时间片使用完了，CPU再次调度，进入到Runnable状态</p>
</li>
<li><p>线程主动调用yield方法，让出CPU资源，进入到Runnable状态</p>
<p><img src="https://i.loli.net/2020/05/03/QkDFudtEg6WXNZj.png" alt=""></p>
</li>
</ul>
<p><strong>阻塞状态</strong></p>
<ul>
<li><p>转换为Terminated状态，调用stop()方法，或者JVM意外Crash；</p>
</li>
<li><p>被转换为Runnable状态，阻塞时间结束，比如读取数据库的数据后</p>
</li>
<li><p>完成了指定时间的休眠，进入到Runnable状态</p>
</li>
<li><p>正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态</p>
</li>
<li><p>线程获取到想要的锁资源，进入到Runnable状态；</p>
</li>
<li><p>线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态</p>
<p><img src="https://i.loli.net/2020/05/03/nNi3HfX7jtlw8kS.png" alt=""></p>
</li>
</ul>
<p><strong>终止状态</strong></p>
<p>一旦线程进入到Terminated状态，意味着这个线程生命的终结；</p>
<ul>
<li>线程正常运行结束，生命周期结束；</li>
<li>线程运行过程中出现错误；</li>
<li>JVM异常结束，所有的线程生命周期均被结束；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/02/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/" data-id="ck9sievu6000jls3b252dfdvh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-UDP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/UDP/" class="article-date">
  <time datetime="2020-05-01T05:38:28.714Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/UDP/">UDP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UDP用户数据报协议"><a href="#UDP用户数据报协议" class="headerlink" title="UDP用户数据报协议"></a>UDP用户数据报协议</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>UDP是一个简单的面向数据报的运输层协议：</p>
<p>进程的每个输出操作都正好产生一个UDP数据报（强调单个），并组装成一份待发送的IP数据报；</p>
<p>对比：多个–》<strong>组成面向流字符</strong>的协议 TCP，应用程序产生的全体数据。</p>
<p><img src="https://i.loli.net/2020/05/01/MLH1a2Yobfk75dr.png" alt=""></p>
<p>​                                                        UDP的封装</p>
<p>UDP不提供可靠性：把应用程序传给IP层的数据发送出去，并不保证他们能够到达目的地。</p>
<p>应用程序必须关心IP数据报的长度，如果超过网络的MTU（2.8字节）就需要对IO数据报进行分片。</p>
<h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p><img src="https://i.loli.net/2020/05/01/IBSHFaxXqf9QZRn.png" alt="UDP首部"></p>
<p>端口号表示发送进程和接收进程，TCP和UDP用目的端口号来获取来自IP层的数据，IP层把数据报分配给TCP和UDP（根据IP首部中协议字段值）</p>
<p>TCP端口和UDP端口相互独立，各自从属的端口由各自协议查看。</p>
<p>UDP长度字段指的是UDP首部和UDP数据的字节长度，该字段最小值为8个字节。</p>
<p>IP数据报长度指的是数据报全长，UDP数据报长度是全长减去IP首部的长度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/01/UDP/" data-id="ck9sievu5000gls3bh645axsw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TCPIP协议族" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/" class="article-date">
  <time datetime="2020-04-30T14:33:35.000Z" itemprop="datePublished">2020-04-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/">TCP/IP协议概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p><img src="https://i.loli.net/2020/05/01/eUWLOGEX4pZ2ln1.png" alt="image-20200430223637420.png"></p>
<p>每一层负责不同的功能：</p>
<p>链路层：设备网卡驱动</p>
<p>网络层：IP协议（网际协议），ICMP协议（Internet互联网控制报文协议）IGMP协议（Internet组管理协议）</p>
<p>运输层：为两台主机上的应用程序提供端到端的通信，</p>
<p>​                UDP（用户数据报协议）：为应用层提供一种非常简单的服务，把数据报的分组从一台主机发送到另一台主机，不保证数据报能到达另一端，可靠性由应用层来提供。</p>
<p>​                TCP（传输控制协议）：为两台主机提供高可靠性的数据通信，把应用程序交给它的数据分成合适的小块交给下面的网络层。</p>
<p>应用层：负责特定的应用程序细节</p>
<p><img src="https://i.loli.net/2020/05/01/wk2KVFqt5jIR4cP.png" alt="image-20200430225910667.png"></p>
<p>FTP是应用层协议，TCP是一种运输层协议，IP是一种网络层协议，而以太网协议则应用与链路层，TCP/IP协议族是一组不同的协议组合在一起构成的协议族。</p>
<p>在TCP/IP协议族中，网络层IP提供是一种不可靠的服务，也就是说它是尽可能快地把分组从源节点送到目的节点，但是不提供任何可靠性保证，TCP在不可靠的IP层提供了一个可靠的传输层，为了提供这种可靠服务，TCP采用了超时重传，发送和接收端到端的确认分组等机制。</p>
<h3 id="TPC-IP的分层"><a href="#TPC-IP的分层" class="headerlink" title="TPC/IP的分层"></a>TPC/IP的分层</h3><p><img src="https://i.loli.net/2020/05/01/YoHX8vqMyTltVuI.png" alt="image-20200430230955893.png"></p>
<p>​        总结： </p>
<p>​        TCP和UDP是著名的传输层协议，二者都使用IP作为网络层协议</p>
<p>​        TCP使用不可靠的IP服务，但是它提供一种可靠的运输层服务</p>
<p>​        UDP为应用程序发送和接收数据报，UDP是不可靠的，不能保证数据报安全无误的到达最        终目的。</p>
<p>​        IP是网络上的主要协议，同时被TCP和UDP使用，TCP和UDP的每组数据通过端系统和每个中间路由器中的IP层在互联网中进行传输。</p>
<p>​        ICMP是IP协议的附属协议，IP层用其与其他主机或路由器交换错误报文和其他重要信息。</p>
<p>​        IGMP是Internet组管理协议，用来把一个UDP数据报多播到多个主机。（广播和多播）</p>
<p>​        ARP（地址解析协议）和 RARP（逆地址解析协议）是某些网络接口使用的特殊协议。用来转换IP层和网络接口层的地址。</p>
<h3 id="互联网地址"><a href="#互联网地址" class="headerlink" title="互联网地址"></a>互联网地址</h3><p><img src="https://i.loli.net/2020/05/01/iAUn7uZNgjY49rc.png" alt="image-20200430232329896.png"></p>
<p>互联网上每个接口必须有一个唯一的地址（IP地址），IP地址长32bit，IP地址具有一定的结构，（32/8）4个十进制的数。</p>
<p>三类IP地址：</p>
<p>单播地址（目的为单个主机）</p>
<p>广播地址（目的端为给定网络上的所有主机）</p>
<p>多播地址（目的端为同一组内的所有主机）</p>
<p><img src="https://i.loli.net/2020/05/01/orTcRiwExnYD7kl.png" alt="image-20200430233316181.png"></p>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>主机名—IP映射</p>
<p>域名系统（DNS）是一个分布的数据库，提供IP地址和主机名之间的映射信息。</p>
<p>任何应用程序都可以调用一个标准的库函数来查看给定名字的主机的IP地址，</p>
<p>系统还提供一个逆函数—给定主机的IP地址，查看对应的主机名</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><img src="https://i.loli.net/2020/05/01/kuRpC3bfnMriJXd.png" alt="image-20200430233514447.png"></p>
<p>应用程序用TCP传送数据时，数据被送入到协议栈中，然后逐个通过每一层直到被当作一串</p>
<p>比特流送入到网路，其中每一层对接收的数据都要增加一些首部数据（有时候还要增加一些尾部数据）</p>
<p>TCP—&gt; IP 称为TCP报文段（TCP segment）</p>
<p>UDP—&gt;IP 称为UDP数据报（UDP datagram）</p>
<p>IP—-&gt;网络接口层 称为IP数据报（IP datagram）</p>
<p>通过以太网传输的比特流称为帧（Frame）</p>
<p>TCP，UDP，ICMP，IGMP都向IP传送数据，IP必须在生成一个IP首部中加入某种表示，</p>
<p>表明数据属于哪一层，协议域：1表示ICMP 2表示IGMP 6表示TCP 17表示UDP</p>
<p>运输层协议在生成报文首部时要存入一个应用程序的标识符。</p>
<p>TCP和UDP都用一个16bit的<strong>端口号</strong>来表示不同的应用程序，</p>
<p>TCP和UDP把源端口号和目的端口号分别存入报文首部中。</p>
<p>同理，以太网要区分IP，ARP，和RARP数据，也要在其首部加入一个16bit的帧类型域。</p>
<h3 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h3><p>其实就是封装的逆过程，去除相应的首部获取真正的数据源。</p>
<p><img src="https://i.loli.net/2020/05/01/EVTexPyjNOlmMwK.png" alt="image-20200430235016887.png"></p>
<p>当目的主机接收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉</p>
<p>各层协议加上的报文首部，每层协议盒都去检查报文首部中的协议标识，以确定接收数据的上层协议。</p>
<p>TODO 协议确实是通过目的端口号，源IP地址和源端口号进行解包的。</p>
<h3 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户-服务器模型"></a>客户-服务器模型</h3><p>应用程序：一端是客户，一端是服务器，服务器为客户提供特定服务。</p>
<p>服务器可分为重复型和并发型</p>
<p>交互：</p>
<p>​    重复型服务器：</p>
<p>​    1.等待一个客户请求到来；</p>
<p>​    2.处理客户请求；</p>
<p>​    3.发送响应给请求的客户；</p>
<p>​    4.返回1；</p>
<p>​    总结：在2步骤中不能为其他客户提供服务；</p>
<p>   并发型服务器：</p>
<p>​    1.等待一个客户请求到来；</p>
<p>​    2.启动一个新的服务器来处理请求，处理结束，终止新的服务器；</p>
<p>​    3.返回1；</p>
<p>​    总结：并发服务器优点就是在于它利用生成其他服务器的方法来处理客户请求，</p>
<p>​                每个客户都有其对应的服务器；</p>
<p>一般来说，TCP服务器是并发的，UDP服务器是重复的。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口如何选择呢？</p>
<p>知名端口号：1-255之间</p>
<p>Unix系统：256-1023之间</p>
<p>注：</p>
<p>服务器</p>
<p>一般都是通过知名端口号来识别的，对于每个TCP/IP实现来说，</p>
<p>FTP服务器的TCP端口号都是21，</p>
<p>每个Telnet服务器的TCP端口号都是23；</p>
<p>每个TFTP（简单文件传送协议）服务器的UDP端口号都是69；</p>
<p>任何TCP/IP实现所提供的服务都是用知名的1-1023之间的端口号；</p>
<p>客户端</p>
<p>通常对所使用的端口号并不关心，只需保证该端口号在本机上是唯一的，</p>
<p>客户端口号又被称为临时端口号（存在时间很短暂）因为通常在用户运行该客户程序时才存在。</p>
<p>临时端口号：1024-5000之间的端口号；</p>
<p>Unix系统文件/etc/services包含了熟知的端口号；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep telnet /etc/services </span><br><span class="line">telnet 23/udp UDP端口号23</span><br><span class="line">telnet 23/tcp TCP端口号23</span><br><span class="line">login  513/tcp 远程登录端口513</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/01/cDl1OagjbtSfk5d.png" alt="image-20200501114740386.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep domain /etc/services</span><br><span class="line">domain 53/udp</span><br><span class="line">domain 53/tcp </span><br><span class="line">使用了UDP端口号53 和TCP端口号53</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/01/7aR13qG5Y4zKPHw.png" alt="image-20200501115926252.png"></p>
<h3 id="标准化过程"><a href="#标准化过程" class="headerlink" title="标准化过程"></a>标准化过程</h3><p>谁控制TCP/IP协议族，谁定义新的标准：</p>
<p>1、Internet协会（ISOC）：推动、支持和促进Internet不断增产和发展的专业组织；</p>
<p>2、Internet体系结构委员会（IAB）： 技术监督和协调；</p>
<p>3、Internet工程专门小组（IETF）：面向近期标准的组织；</p>
<p>4、Internet研究专门小组（IRIF）：长远项目研究；</p>
<h3 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h3><p>所有关于Internet的正式标准都是RFC 文档出版，出版的目的只是为了提供信息，更改了那些东西，（地址，端口号）；</p>
<p>1）赋值RFC</p>
<p>2）Internet正式协议标准</p>
<p>3）主机需求RFC</p>
<p>4）路由器需求RFC</p>
<h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p>Internet 和 internet 的区别</p>
<p>internet意思是用一个共同的协议族把多个网络连接在一起，</p>
<p>Internet指的是世界范围内通过TCP/IP互相通信的所有主机集合（more than  1000000）；</p>
<p>Internet是一个internet，但是internet不等于Internet</p>
<h3 id="应用编程接口"><a href="#应用编程接口" class="headerlink" title="应用编程接口"></a>应用编程接口</h3><p>使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：<strong>Socket</strong>和<strong>TLI</strong>（运输层接口）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP/IP协议族分为四层：</p>
<p>链路层、网络层、运输层、应用层；</p>
<p>网络层（IP）提供点到点的服务；</p>
<p>运输层（TCP和UDP）提供端到端的服务；</p>
<p>每个接口都用IP地址标识，域名系统（DNS）为主机名和IP地址之间提供动态的映射</p>
<p>端口号用来标识互相通信的应用程序，</p>
<p>服务器使用知名端口号，</p>
<p>客户使用临时设定的端口号。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/04/30/TCPIP%E5%8D%8F%E8%AE%AE%E6%97%8F/" data-id="ck9sievu3000cls3b3rky9gc6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/" rel="tag">面试集锦</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 20px;">多线程</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/" style="font-size: 10px;">面试集锦</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/04/%E9%9D%A2%E8%AF%95/">面试</a>
          </li>
        
          <li>
            <a href="/2020/05/04/Vultr/">Vultr</a>
          </li>
        
          <li>
            <a href="/2020/05/03/Android%E5%A4%8D%E4%B9%A0/">Android面试集锦（一）内存泄露篇</a>
          </li>
        
          <li>
            <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/">Java多线程（三）线程池Callable 和 Future</a>
          </li>
        
          <li>
            <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/">Java多线程（四）ThreadPoolExecutor相关知识</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 HashWaney<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>