<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HashWaney</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="HashWaney">
<meta property="og:url" content="http://hashwaney.github.io/index.html">
<meta property="og:site_name" content="HashWaney">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="HashWaney">
<meta property="article:tag" content="coder">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HashWaney" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HashWaney</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Action and Thinking</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hashwaney.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java内存模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-05-05T10:40:00.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="noopener">原文地址</a></p>
<p><strong>前言</strong></p>
<p>Java内存模型指定Java虚拟机如何与计算机的内存（RAM）一起使用。 Java虚拟机是整个计算机的模型，因此该模型自然包含一个内存模型-AKA Java内存模型。</p>
<p>如果要正确设计行为并发的程序，那么了解Java内存模型非常重要。 Java内存模型指定不同线程如何以及何时看到其他线程写入共享变量的值，以及在必要时如何同步对共享变量的访问。</p>
<p>原始的Java内存模型不足，因此Java内存模型在Java 1.5中进行了修订。 此版本的Java内存模型仍在Java 8中使用。</p>
<p><strong>内部Java内存模型</strong><br>JVM内部使用的Java内存模型在线程堆栈和堆之间分配内存。 此图从逻辑角度说明了Java内存模型：</p>
<p><img src="https://i.loli.net/2020/05/05/UG4kyrLWEdCanOe.png" alt=""></p>
<p>Java虚拟机中运行的每个线程都有其自己的线程堆栈。线程堆栈包含有关线程调用了哪些方法以达到当前执行点的信息。我将其称为“调用堆栈”。当线程执行其代码时，调用堆栈会更改。</p>
<p>线程堆栈还包含正在执行的每个方法（调用堆栈上的所有方法）的所有局部变量。线程只能访问自己的线程堆栈。由线程创建的局部变量对创建线程之外的所有其他线程不可见。即使两个线程执行的代码完全相同，这两个线程仍将在各自的线程堆栈中创建该代码的局部变量。因此，每个线程对每个局部变量都有其自己的版本。</p>
<p>所有原始类型的本地变量（布尔值，字节，短型，字符型，整数，长型，浮点型，双精度型）都已完全存储在线程堆栈中，因此其他线程不可见。一个线程可以将一个主要变量的副本传递给另一个线程，但是它不能共享原始局部变量本身。</p>
<p>堆包含在Java应用程序中创建的所有对象，而与创建该对象的线程无关。这包括原始类型的对象版本（例如Byte，Integer，Long等）。创建对象并将其分配给局部变量，或者将其创建为另一个对象的成员变量都没有关系，该对象仍存储在堆中。</p>
<p>这是说明调用堆栈和存储在线程堆栈上的局部变量以及存储在堆上的对象的图：</p>
<p><img src="https://i.loli.net/2020/05/05/iBxPvjfSe6OXRFY.png" alt=""></p>
<p>局部变量可以是原始类型，在这种情况下，它完全保留在线程堆栈中。</p>
<p>局部变量也可以是对对象的引用。在这种情况下，引用（局部变量）存储在线程堆栈中，但是对象本身（如果存储在堆中）。</p>
<p>一个对象可能包含方法，而这些方法可能包含局部变量。即使这些方法所属的对象存储在堆中，这些局部变量也存储在线程堆栈中。</p>
<p>对象的成员变量与对象本身一起存储在堆中。当成员变量是基本类型时，以及它是对对象的引用时，都是如此。</p>
<p>静态类变量也与类定义一起存储在堆中。</p>
<p>引用对象的所有线程都可以访问堆上的对象。当线程可以访问对象时，它也可以访问该对象的成员变量。如果两个线程同时在同一个对象上调用一个方法，则它们都可以访问该对象的成员变量，但是每个线程将拥有自己的局部变量副本。</p>
<p>这是说明以上几点的图：</p>
<p><img src="https://i.loli.net/2020/05/05/lLcNsOnFrP8Vyd9.png" alt=""></p>
<p>两个线程具有一组局部变量。局部变量之一（局部变量2）指向堆上的共享对象（对象3）。这两个线程分别具有对同一对象的不同引用。它们的引用是局部变量，因此存储在每个线程的线程堆栈中（在每个线程上）。但是，两个不同的引用指向堆上的同一对象。</p>
<p>注意共享对象（对象3）如何引用对象2和对象4作为成员变量（由对象3到对象2和对象4的箭头所示）。通过对象3中的这些成员变量引用，两个线程可以访问对象2和对象4。</p>
<p>该图还显示了一个局部变量，该局部变量指向堆上的两个不同对象。在这种情况下，引用指向两个不同的对象（对象1和对象5），而不是同一对象。理论上，如果两个线程都引用了两个对象，则两个线程都可以访问对象1和对象5。但是在上图中，每个线程仅具有对两个对象之一的引用。</p>
<p>那么，哪种Java代码可能导致上面的内存图？ 好吧，代码和下面的代码一样简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class MyRunnable implements <span class="title">Runnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        methodOne();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localVariable1 = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">        MySharedObject localVariable2 =</span><br><span class="line">            MySharedObject.sharedInstance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... do more with local variables.</span></span><br><span class="line"></span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer localVariable1 = <span class="keyword">new</span> Integer(<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... do more with local variable.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySharedObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static variable pointing to instance of MySharedObject</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySharedObject sharedInstance =</span><br><span class="line">        <span class="keyword">new</span> MySharedObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//member variables pointing to two objects on the heap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer object2 = <span class="keyword">new</span> Integer(<span class="number">22</span>);</span><br><span class="line">    <span class="keyword">public</span> Integer object4 = <span class="keyword">new</span> Integer(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> member1 = <span class="number">67890</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有两个线程正在执行run（）方法，那么前面显示的图就是结果。 run（）方法调用methodOne（），methodOne（）调用methodTwo（）。</p>
<p>methodOne（）声明一个原始的局部变量（int类型的localVariable1）和一个作为对象引用的局部变量（localVariable2）。</p>
<p>每个执行methodOne（）的线程将在其各自的线程堆栈上创建其自己的localVariable1和localVariable2副本。 localVariable1变量将完全彼此分离，仅存在于每个线程的线程堆栈中。一个线程看不到另一个线程对其localVariable1副本所做的更改。</p>
<p>每个执行methodOne（）的线程还将创建自己的localVariable2副本。但是，localVariable2的两个不同副本最终都指向堆上的同一对象。该代码将localVariable2设置为指向静态变量引用的对象。静态变量只有一个副本，并且此副本存储在堆中。因此，localVariable2的两个副本最终都指向静态变量指向的MySharedObject的同一实例。 MySharedObject实例也存储在堆中。它对应于上图中的对象3。</p>
<p>注意MySharedObject类也包含两个成员变量。成员变量本身与对象一起存储在堆中。这两个成员变量指向另外两个Integer对象。这些整数对象对应于上图中的对象2和对象4。</p>
<p>还要注意methodTwo（）如何创建一个名为localVariable1的局部变量。此局部变量是对Integer对象的对象引用。该方法将localVariable1引用设置为指向新的Integer实例。执行methodTwo（）的每个线程的localVariable1引用将存储在一个副本中。实例化的两个Integer对象将存储在堆中，但是由于该方法每次执行该方法时都会创建一个新的Integer对象，因此执行此方法的两个线程将创建单独的Integer实例。在methodTwo（）内部创建的Integer对象对应于上图中的对象1和对象5。</p>
<p>还请注意，类型为long的MySharedObject类中的两个成员变量是基本类型。由于这些变量是成员变量，因此它们仍与对象一起存储在堆中。仅局部变量存储在线程堆栈上。</p>
<p><strong>硬件内存架构</strong></p>
<p>现代硬件内存体系结构与内部Java内存模型有所不同。 同样重要的是，还要了解硬件内存架构，并了解Java内存模型如何与之协同工作。 本节描述了常见的硬件内存体系结构，下一节将描述Java内存模型如何与之协同工作。</p>
<p>这是现代计算机硬件体系结构的简化图：</p>
<p><img src="https://i.loli.net/2020/05/05/tih8RO3AV9ISakc.png" alt=""></p>
<p>现代计算机通常其中装有2个或更多CPU。其中一些CPU也可能具有多个内核。关键是，在具有2个或更多CPU的现代计算机上，可能同时运行多个线程。每个CPU都可以在任何给定时间运行一个线程。这意味着，如果您的Java应用程序是多线程的，则每个CPU可能在Java应用程序中同时（并发）运行一个线程。</p>
<p>每个CPU包含一组寄存器，这些寄存器本质上是CPU内存。 CPU在这些寄存器上执行操作的速度比对主存储器中的变量执行操作的速度快得多。这是因为CPU可以比访问主存储器更快地访问这些寄存器。</p>
<p>每个CPU可能还具有一个CPU缓存存储层。实际上，大多数现代CPU都具有一定大小的缓存层。 CPU可以比主存储器更快地访问其高速缓存，但是通常不如其访问内部寄存器的速度快。因此，CPU高速缓存存储器位于内部寄存器和主存储器之间的速度之间。某些CPU可能具有多个高速缓存层（第1级和第2级），但是了解Java内存模型如何与内存交互并不重要。重要的是要知道CPU可以具有某种高速缓存层。</p>
<p>计算机还包含一个主存储区（RAM）。所有CPU都可以访问主存储器。主存储区通常比CPU的高速缓存大得多。</p>
<p>通常，当CPU需要访问主内存时，它将部分主内存读入其CPU缓存。它甚至可以将缓存的一部分读入其内部寄存器，然后对其执行操作。当CPU需要将结果写回主存储器时，它将把值从其内部寄存器刷新到高速缓存，然后在某个时候将值刷新回主存储器。</p>
<p>当CPU需要将其他内容存储在高速缓存中时，通常会将高速缓存中存储的值刷新回主存储器。 CPU高速缓存可以一次将数据写入其部分内存，并一次刷新其部分内存。它不必每次更新都读取/写入完整的缓存。通常，缓存在称为“缓存行”的较小存储块中更新。可以将一个或多个高速缓存行读入高速缓存存储器，并且可以将一个或多个高速缓存行再次刷新回主存储器。</p>
<p><strong>Java内存模型和硬件内存架构之间的桥接</strong></p>
<p>如前所述，Java内存模型和硬件内存体系结构是不同的。 硬件内存体系结构不能区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主内存中。 有时，部分线程堆栈和堆可能会出现在CPU缓存和内部CPU寄存器中。 下图对此进行了说明：</p>
<p><img src="https://i.loli.net/2020/05/05/awz1xXBOfhci5P3.png" alt=""></p>
<p>当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：</p>
<ul>
<li>线程对共享变量修改的可见性</li>
<li>当读，写和检查共享变量时出现race conditions</li>
</ul>
<p>下面我们专门来解释以下这两个问题.</p>
<p><strong>共享对象的可见性</strong></p>
<p>如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，一个线程更新这个共享对象可能对其它线程来说是不可见的。</p>
<p>想象一下，共享对象被初始化在主内存中。跑在CPU上的线程将这个共享对象读到CPU缓存中。然后修改了这个对象。只要CPU缓存没有被刷新到主内存，对象修改后的版本对跑在其他CPU上的线程都是不可见的。这种方式可能导致每个线程拥有这个共享对象的私有拷贝。每个拷贝停留在不同的CPU缓存中。</p>
<p>下图示意了这种情形。跑在左边CPU的线程拷贝这个共享对象到它的CPU缓存中，然后将count变量的值修改为2。这个修改对跑在右边CPU上的其它线程是不可见的，因为修改后的count的值还没有被刷新回主存中去。</p>
<p><img src="https://i.loli.net/2020/05/05/wIz682AsDu3SEjg.png" alt=""></p>
<p>要解决此问题，可以使用Java的volatile关键字。 volatile关键字可以确保给定的变量直接从主存储器中读取，并在更新时始终写回到主存储器中。</p>
<p><strong>Race Conditions(竞争条件)</strong></p>
<p>如果两个或多个线程共享一个对象，并且有多个线程更新该共享对象中的变量，则可能会发生竞争条件。</p>
<p>想象一下，线程A是否将共享对象的变量计数读入其CPU缓存中。 还要想象一下，线程B的功能相同，但是它位于不同的CPU缓存中。 现在线程A加一个要计数，线程B执行相同的操作。 现在var1已增加两次，在每个CPU高速缓存中增加一次。</p>
<p>如果这些增加是顺序执行的，则变量计数将增加两次，并将原始值+ 2写回到主存储器。</p>
<p>但是，这两个增量是在没有适当同步的情况下同时执行的。 无论线程A和B中哪个线程将其更新的版本写回主内存，尽管有两个增量，更新后的值仅比原始值高1。</p>
<p>该图说明了如上所述的竞争条件问题的发生：</p>
<p><img src="https://i.loli.net/2020/05/05/KAMRaJgyNetomTz.png" alt=""></p>
<p>解决这个问题可以使用Java同步块。一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" data-id="ck9tzqm330001s23b1nq47nip" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" rel="tag">【Java并发编程】</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2020-05-04T02:15:39.294Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/%E9%9D%A2%E8%AF%95/">面试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>App启动到主页面经历过程</p>
<p><a href="https://www.jianshu.com/p/a72c5ccbd150" target="_blank" rel="noopener">https://www.jianshu.com/p/a72c5ccbd150</a></p>
<p><a href="https://www.yuque.com/richuangangban/mtbug7/ckek0r#efUyj" target="_blank" rel="noopener">https://www.yuque.com/richuangangban/mtbug7/ckek0r#efUyj</a></p>
<p><a href="https://www.yuque.com/docs/share/73271436-56d3-4c63-9311-ae499378198a" target="_blank" rel="noopener">https://www.yuque.com/docs/share/73271436-56d3-4c63-9311-ae499378198a</a></p>
<p><a href="https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Android相关/Android高级面试题.md" target="_blank" rel="noopener">https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Android%E7%9B%B8%E5%85%B3/Android%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98.md</a></p>
<p>简历编写</p>
<p><a href="https://www.jianshu.com/p/855ff21e0a13" target="_blank" rel="noopener">https://www.jianshu.com/p/855ff21e0a13</a></p>
<p>JVM理解</p>
<p><a href="https://blog.csdn.net/mmc_maodun/category_9262116.html" target="_blank" rel="noopener">https://blog.csdn.net/mmc_maodun/category_9262116.html</a></p>
<p>Java基础</p>
<p><a href="https://blog.csdn.net/ns_code/article/details/8846697" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/8846697</a></p>
<p>Java并发编程</p>
<p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/04/%E9%9D%A2%E8%AF%95/" data-id="ck9tzqm3c000gs23b2xw9djyi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vultr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/04/Vultr/" class="article-date">
  <time datetime="2020-05-04T01:34:12.684Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/04/Vultr/">Vultr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Vultr搭建SS步骤"><a href="#Vultr搭建SS步骤" class="headerlink" title="Vultr搭建SS步骤"></a>Vultr搭建SS步骤</h3><hr>
<p>自动一键安装SS</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>

<p>输入SS的密码，端口和加密方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Please enter password for shadowsocks-python</span><br><span class="line">(Default password: teddysun.com):your password</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">password = your password </span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line">Please enter a port for shadowsocks-python [1-65535]</span><br><span class="line">(Default port: 10853):your port </span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">port = your port </span><br><span class="line">---------------------------</span><br><span class="line">Please select stream cipher for shadowsocks-python:</span><br><span class="line">1) aes-256-gcm</span><br><span class="line">2) aes-192-gcm</span><br><span class="line">3) aes-128-gcm</span><br><span class="line">4) aes-256-ctr</span><br><span class="line">5) aes-192-ctr</span><br><span class="line">6) aes-128-ctr</span><br><span class="line">7) aes-256-cfb</span><br><span class="line">8) aes-192-cfb</span><br><span class="line">9) aes-128-cfb</span><br><span class="line">10) camellia-128-cfb</span><br><span class="line">11) camellia-192-cfb</span><br><span class="line">12) camellia-256-cfb</span><br><span class="line">13) chacha20-ietf-poly1305</span><br><span class="line">14) chacha20-ietf</span><br><span class="line">15) chacha20</span><br><span class="line">16) rc4-md5</span><br><span class="line">Which cipher you'd select(Default: aes-256-gcm):7</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">cipher = aes-256-cfb</span><br><span class="line">---------------------------</span><br><span class="line">Congratulations, Shadowsocks-python server install completed!</span><br><span class="line">Your Server IP        :  your ip address</span><br><span class="line">Your Server Port      :  your port </span><br><span class="line">Your Password         :  your password</span><br><span class="line">Your Encryption Method:  aes-256-cfb </span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/342.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/04/Vultr/" data-id="ck9tzqm3a000as23b8ouubo28" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Android复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Android%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Android%E5%A4%8D%E4%B9%A0/">Android面试集锦（一）内存泄露篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Android中常见的内存泄露汇总</strong></p>
<ul>
<li><p><strong>单例造成的内存泄露</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Holder holder;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context =context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(holder==<span class="keyword">null</span>)&#123;</span><br><span class="line">            holder =<span class="keyword">new</span> Holder(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通的单例模式，注意这里的Context 的生命周期长短决定了是否会发生内存泄露</span></span><br><span class="line"><span class="number">1</span>.如果是Application的Context，不会有啥问题，因为静态变量的生命周期和Application的Context的生命周期一样长；</span><br><span class="line"><span class="number">2</span>.如果传入的是Activity的Context，那么当Activity退出了，该Context的引用被单例对象持有，无法得到内存释放，因此无法释放，就造成了内存泄露；</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>集合类泄露</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态的集合持有Object的引用，当object=null仅仅是释放了引用本身，</span></span><br><span class="line"><span class="comment">//Vector这个静态变量仍然引用该对象，所以这个对象对于GC来说是不可以回收的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector&lt;Object&gt; vector =<span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    vector.add(obj);</span><br><span class="line">    object=<span class="keyword">null</span>; <span class="comment">//仅仅是释放了对象本身的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化方案，释放静态变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector =<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>非静态内部类创建一个静态实例</strong></p>
<p>非静态内部类创建了一个静态的实例对象，该实例对象生命周期和应用的生命周期一样长，然而非静态内部类是会去持有外部类的引用的，就好比有了父子之间的关系，在一个类中创建了内部类，他们就有关系了，</p>
<p>内部类持有外部类的名片表明自己是谁家的。OK，那么既然非静态内部类创建了一个静态实例变量，那么意味着静态变量持有了Activity的引用，那么又是去比较生命周期了，静态变量的生命周期很长，那么Activity总会销毁，但是静态变量持有它的引用，意味着它是可达的，根据GC的回收算法，如果一个对象不可达说明其是可以进行回收的，既然Activity已经销毁了，没作用了，但是难点听占着茅坑不拉屎，占用一部分内存空间，这样导致无法回收了，就会造成Activity的内存泄露了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceManager mResourceManager =<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResourceManager==<span class="keyword">null</span>)&#123;</span><br><span class="line">            mResourceManager = <span class="keyword">new</span> ResourceManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ResourceManager</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//为了防止内存泄露,将该内部置空</span></span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mResourceManager=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以将该内部类设为静态内部类，</span></span><br><span class="line"><span class="comment">//也可以将该内部类抽取出来封装为一个单例对象；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匿名内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Runnable reference1 = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Runnable reference2 =<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(reference1).start();</span><br><span class="line">    <span class="comment">//解决方案：静态内部类 异步线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原因：匿名内部类会持有当前MainActivity.this,如果将这个引用传入到一个异步线程中,此线程和Activity的生命周期不一致的时候，有可能Activity此时跳转页面销毁了，而线程还没有结束生命，这个时候就会发生MainActivity的内存泄露</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Handler</strong></p>
<p>Handler、Message、MessageQueue都是相互关联起来的，如果Handler发送的Message没有被处理，那么</p>
<p>Handler和Message就会被MessageQueue一直持有，因为消息始终是需要Handler去MessageQueue中去取以及处理的，</p>
<p>那么假如在主线程中发送一个延迟10分钟的消息，Handler把发送到消息队列中，那么这个时候Activity突然被finish掉了，延迟执行的Message还会继续存在主线程中，该Message会持有Handler引用，然后Handler是声明称非静态内部类，它会持有Activity的引用，那么在Activity调用finish就不会进行回收了，从而导致内存泄露；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHandleLeakActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Handler mLeakHandler = <span class="keyword">new</span> Handler&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle args)</span></span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.onCreate(args);</span><br><span class="line">          mLeakHandler.postDelayed(<span class="keyword">new</span> Runnable&#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                  <span class="comment">// ... </span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,<span class="number">1000</span>*<span class="number">60</span>*<span class="number">10</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//此时突然调用finish();</span></span><br><span class="line">          finish();</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 解决版本////</span></span><br><span class="line">  <span class="number">1</span>.将Handler声明为静态内部类</span><br><span class="line">  <span class="number">2</span>.将Activity声明为弱引用供Handler使用，使用之前进行判空处理</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> LeakHandler mHandler = <span class="keyword">new</span> LeakHandler(<span class="keyword">this</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle args)</span></span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.onCreate(args);</span><br><span class="line">          mHandler.postDelayed(sRunnable,<span class="number">1000</span>*<span class="number">60</span>*<span class="number">10</span>);</span><br><span class="line">          finish();</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//移除MessageQueue中的消息，</span></span><br><span class="line">         	<span class="comment">//防止Looper线程中的消息队列还有可能要处理的消息，这里我已经销毁了，</span></span><br><span class="line">          <span class="comment">//将不再处理消息了</span></span><br><span class="line">          mHandler.removeCallbackAndMessages(<span class="keyword">null</span>);</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;XXXActivity&gt; act;</span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="title">LeakHandler</span><span class="params">(XXXActivity activity)</span></span>&#123;</span><br><span class="line">              act =<span class="keyword">new</span> WeakReference&lt;XXXActivity&gt;(activity);</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message m)</span></span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(ref.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  <span class="comment">//....</span></span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//自然这里的Runnable也需要声明为静态的实例和静态的Handler保持一致</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Runnable sRunnable = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综述：即推荐静态内部了+WeakReference方法，每次使用之前注意判空；</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>级别</th>
<th>回收时机</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强</td>
<td>从来不会</td>
<td>new 创建出来的对象，提供对象的一般属性</td>
<td>JVM停止运行时终止</td>
</tr>
<tr>
<td>软</td>
<td>在内存不足时</td>
<td>联合ReferenceQueue构造有效期短/占用内存大/生命周期长的对象的二级高速缓冲器（内存不足才清空）</td>
<td>内存不足终止</td>
</tr>
<tr>
<td>弱</td>
<td>垃圾回收时</td>
<td>联合ReferenceQueue构造有效期短/占用内存大/生命周期长的对象的一级高速缓冲器（系统发生gc则清空）</td>
<td>gc运行后终止</td>
</tr>
<tr>
<td>虚</td>
<td>垃圾回收时</td>
<td>联合ReferenceQueue来跟踪对象被垃圾回收器回收的活动</td>
<td>gc运行后终止</td>
</tr>
</tbody></table>
<p>  在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量的使用软引用和弱引用技术；</p>
<p>  软/弱引用可以和一个引用队列（ReferenceQueue)联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引入队列中，利用这个引用队列可以得知被回收的软/弱引用的对象列表，从而可以告知缓冲器清除已经失效的软/弱引用；</p>
<p>  <strong>应用：如果程序中大量默认图片，比如默认的头像，默认的logo等等，这些图片很多地方用到，如果每次取读取图片，如果每次去读取图片，由于读取文件需要IO操作，速度慢，性能地下，可以考虑将图片缓存起来，需要的时候直接从内存中读取，由于图片占用内存空间比较大，缓存很多图片需要很多内存，可能就会发生OOM，考虑使用软/弱引用技术来避免这个问题发生。</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String,SoftReference&lt;Bitmap&gt;&gt;imageCache =<span class="keyword">new</span> HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个类，用来保存Bitmap的软引用到HashMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBitmapUtil</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个HashMap,保存软引用对象</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache =<span class="keyword">new</span> HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义一个方法，保存Bitmap的软引用到HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//强引用的Bitmap对象</span></span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">        <span class="comment">//将强引用转换为软引用Bitmap对象</span></span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line">        <span class="comment">//添加软引用Bitmap到Map中，加载到内存</span></span><br><span class="line">        imageCache.put(path,softBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Bitmap对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapByPath</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">        <span class="comment">//从缓存中获取软引用的Bitmap对象</span></span><br><span class="line">        SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get();</span><br><span class="line">        <span class="comment">//判断软引用是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(softBitmap==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过软引用取出Bitmap对象，如果由于内存不足Bitmap被回收，将取空，</span></span><br><span class="line">        <span class="comment">//如果未被回收，则可重复使用，提供速度</span></span><br><span class="line">        <span class="keyword">if</span>(softBitmap.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> softBitmap.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>使用软引用后，在发生OOM异常之前，这些缓存的图片资源的内存空间可以被释放掉，从而避免因为内存达到上限，防止Crash发生</strong></p>
<p>  如果对象可能经常使用，尽量使用软引用，如果对象使用不频繁，使用弱引用    </p>
<ul>
<li><p><strong>尽量避免使用static成员变量</strong></p>
<p>如果成员变量被声明为static，那么我们知道其生命周期将与整个app进程生命周期一样，</p>
<p>问题1.如果app进程设计上是常驻内存的，即使app切换到后台，这部分内存也不会被释放，按照app内存管理机制，占用内存较大的后台进程将优先回收；如果app做过进程互相保活的，会造成app在后台频繁重启，会消耗电量流量。app容易被用户卸载和静默</p>
<p>修复：</p>
<p>不要在类初始化时候初始化静态变量成员，可以使用lazy初始化，管理好对象的生命周期，如果应用退出，合理的进行对象的销毁操作；</p>
</li>
<li><p><strong>资源未关闭</strong></p>
<p>对于使用了BroadcastReceiver、ContentObserver、File、Cursor、Stream、Bitmap等资源，应该在Activity销魂的时候及时关闭，否则这些资源将不会被回收，造成内存泄露</p>
</li>
<li><p><strong>不良代码造成的内存压力</strong></p>
<p>比如Bitmap没有调用recycle()方法，对于Bitmap对象在不使用的时候，应该调用recycle()释放内存，然后才把它置为null；因为加载Bitmap对象的内存空间，一部分是Java的，一部分是C的（bitmap的分配底层是通过JNI调用的）recycle就是针对C部分的内存释放；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Bitmap bitmap =<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">getBitmap</span><span class="params">(String path)</span></span>&#123;</span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bitmap!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        bitmap.recycle();</span><br><span class="line">        bitmap=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>总结</strong></p>
<p>1.对于Activity等组件的引用应该控制在Activity的生命周期之内，如果不能考虑使用getApplicationContext() 或者getApplication；以避免Activity被外部生命周期长的对象引用而导致了内存泄漏；</p>
<p>2.尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（类变量）《包括context》即使要使用，也要考虑在适当时候将外部成员变量置空，也可以在内部类中使用弱引用来引用外部类的变量；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将内部类改为静态内部类</span><br><span class="line">改造完之后的静态内部类使用弱引用来引用外部类的成员变量</span><br></pre></td></tr></table></figure>

<p>3.Handler持有的引用对象最好使用弱引用，资源释放时候也可以清空Handler里的消息（Hnadler.removeCallback());–调用时机（Activity的onStop 和 onDestroy执行时候）</p>
<p>4.Java的实现过程中，也要考虑其对象的释放，最好的方法就是在不使用某对象的时候，显示地将对象赋值为null.比如使用完了Bitmap，调用recycle，在赋值为null，清空对图片资源的直接饮用或间接引用，数组（array.clear() ; array=null)</p>
<p>5.正确关闭资源，对于使用了BroadcastReceiver,ContentObserver,File,Cursor,Stream,Bitmap资源，在Activity销毁时候及时的关闭和注销；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Android%E5%A4%8D%E4%B9%A0/" data-id="ck9tzqm2z0000s23b4aeier08" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/" rel="tag">面试集锦</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(五) 生产者与消费者模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)%20%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)%20%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/">Java多线程（五）生产者和消费者模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>概念</strong></p>
<p>生产者消费者问题是线程模型中的经典问题，生产者和消费者在同一时间段共用同一存储空间，生产者向空间里面产生数据，消费者则取走数据；</p>
<p>实现情况：</p>
<p>生产者<strong>不断交替</strong>地产生数据“a”,”b”….，消费者<strong>不断交替</strong>地取走数据；</p>
<p>问题：</p>
<p>1.假设生产者线程刚向数据存储空间添加数据，还没加入，程序切换到消费者线程，消费者线程将取出的数据就是上一次的生产者添加的数据，那么这样是不是会造成数据错乱</p>
<p>2.生产者生产了若干数据，消费者才开始取数据，那么这样的结果就会是消费者取出的数据和预想的生产一个取出一个不一致；</p>
<p>那么问题1需要通过同步来解决，问题2需要线程间通信来解决；</p>
<p>当存储空间为空时候，消费者阻塞，当存储空间满的时候，生产者阻塞；</p>
<p><strong>总结：生产者消费者存在同步问题，线程间通信问题，那么可以使用wait/notify机制实现1.生产者线程放入一个数据，2.通知消费者线程取出数据，3.消费者线程取出数据后，通知生产者生产数据</strong> </p>
<p><strong>1. wait() 和 notify() 实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String fullLock=<span class="string">"fullLock"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> voud <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(),<span class="string">"Producer Thread:"</span>+i).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(),<span class="string">"Customer Thread:"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1999</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(fullLock)&#123;</span><br><span class="line">                <span class="keyword">while</span>(count==<span class="number">10</span>)&#123;</span><br><span class="line">                    <span class="comment">//阻塞</span></span><br><span class="line">                    fullLock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                fullLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;=<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1999</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span>(fullLock)&#123;</span><br><span class="line">                <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//内存中数据了，</span></span><br><span class="line">                  	fullLock.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                fullLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">实验结果</span><br><span class="line">----</span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">4</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">4</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">---------------</span><br></pre></td></tr></table></figure>

<p><strong>2.可重入锁ReentrantLock</strong></p>
<p>​    可重入：某个线程已经获取了某个锁，再次获取锁而不会出现死锁；synchronized也是可重入的，但是使用ReentrantLock的话，才可以显示的控制锁，synchronized则是对锁的隐式控制；所以ReentrantLock是需要自己手动管理锁的加锁和解锁，还有加锁次数和解锁次数一定要一致；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock lock =<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Condition notFull  = <span class="keyword">new</span> Condition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Condition notEmpty = <span class="keyword">new</span> Condition();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(),<span class="string">"Producer-Thread-"</span>+i).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(),<span class="string">"Customer-Thread-"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1999</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackPrint();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="keyword">while</span>(count==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    notEmpty.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                  count++;</span><br><span class="line">                  notEmpty.signal();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1999</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        notFull.await();<span class="comment">//发个等待信号</span></span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                notFull.signal(); <span class="comment">//发个信号生产</span></span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">实验结果</span><br><span class="line">----</span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">0</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">生产者<span class="number">1</span>生产者生产，目前总共有<span class="number">2</span></span><br><span class="line">生产者<span class="number">2</span>生产者生产，目前总共有<span class="number">3</span></span><br><span class="line">生产者<span class="number">3</span>生产者生产，目前总共有<span class="number">4</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">3</span></span><br><span class="line">消费者<span class="number">1</span>消费者消费，目前总共有<span class="number">2</span></span><br><span class="line">消费者<span class="number">2</span>消费者消费，目前总共有<span class="number">1</span></span><br><span class="line">消费者<span class="number">3</span>消费者消费，目前总共有<span class="number">0</span>    </span><br><span class="line">----</span><br></pre></td></tr></table></figure>

<p><strong>3.阻塞队列BlockingQueue实现</strong></p>
<p>即阻塞队列，某些情况下对阻塞队列的访问可能造成阻塞</p>
<p>被阻塞的情况下</p>
<p>1.当队列满了的时候，添加数据到队列中；</p>
<p>2.当队列空了的时候，从队列中取出数据；</p>
<p>so：当一线程对已经满了的阻塞队列进行入队操作时候会阻塞，除非有另外一个线程进行了出队操作，当一个线程对一个空的阻塞队列进行出队操作会阻塞，除非有另外一个线程进行了入队操作；</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛异常</th>
<th>特定值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(o)</td>
<td>offer(o)</td>
<td>put(o)</td>
<td>offer(o,timeout,timeunit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove(o)</td>
<td>poll(o)</td>
<td>take(o)</td>
<td>poll(timeout,timeunit)</td>
</tr>
<tr>
<td>检查</td>
<td>element(o)</td>
<td>peek(o)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>感觉这种实现方式不太靠谱；生产者和消费者不是</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)%20%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" data-id="ck9tzqm370004s23bapfw9o01" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" rel="tag">【Java并发编程】</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(三)线程池之Callable和Future" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/">Java多线程（三）线程池Callable 和 Future</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>线程池概念和Executors类的应用</strong></p>
<p>在TCP服务器编程模型中，当一个客户端连接到服务器，服务器要起一个线程为之服务，当客户端的会话结束后，</p>
<p>线程也就结束。</p>
<p>即每一个客户端连接，服务器就要为之创建一个新的线程。</p>
<p>如果访问服务器的客户端很多，那么服务器就会不断的创建和销毁线程，那么这样就严重影响服务器的性能；</p>
<p>怎么解决：</p>
<p>可以创建一些线程，这些线程构成的集合就称为线程池，当服务器接收到一个客户端请求后，就从线程池中取出一个空闲的线程，服务完成之后，不关闭该线程，而是将该线程还回线程池中。</p>
<p>在线程池的编程模式下，任务是交给整个线程池的，而不是直接交给某个线程；</p>
<p>线程池拿到任务后，就在内部找有空闲的线程，再把任务交给某个空闲的线程，</p>
<p><strong>任务是交给整个线程池，但是可以同时向一个线程池中提交多个任务。</strong></p>
<p>#####一些常用的线程池API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建固定大小的线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">threadPool.execute(Runnable runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建缓存的线程池（如果线程不够自动创建新的线程满足服务）</span></span><br><span class="line">ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">threadPool.execute(Runnable runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单一线程池（线程池里面只有一个线程，如果意外死亡，那么系统就自动创建一个新的线程来代替）</span></span><br><span class="line">ExecutorService	threadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">threadPool.execute(Runnable runnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行完任务后关闭线程池</span></span><br><span class="line">threadPool.shutdown();</span><br><span class="line"><span class="comment">//不管任务是否完成都关闭线程池</span></span><br><span class="line">threadPool.shutdownNow();</span><br><span class="line"></span><br><span class="line"><span class="comment">//用线程池启动定时器，每隔20秒执行一次任务</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">3</span>).scheudle(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">20</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<h4 id="Callable-与-Runnable"><a href="#Callable-与-Runnable" class="headerlink" title="Callable 与 Runnable"></a>Callable 与 Runnable</h4><p>java.lang.Runnable ，是一个接口，声明一个run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于run()方法返回值为void类型，<strong>so在执行完任务之后无法返回任何结果</strong>。</p>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面声明了一个方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exceptions</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出这是一个泛型接口，声明一个call方法，<strong>同时这个方法可以有返回值V，返回的类型就是传递进来的V类型</strong>，当然也可以抛出异常；</p>
<p>如何使用Callable? 一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明若干个submit方法的重载版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交一个实现Callable接口的任务，并且返回了封装了异步计算结果的Future</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; taks)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task,T result)</span></span>;</span><br><span class="line"><span class="comment">//提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future 就是对于具体的Runnable或者Callable任务的<strong>执行结果</strong> 相关操作：进行取消，查询是否完成，获取结果。</p>
<p>可以通过<strong>get()方法</strong>获取执行结果，<strong>该get()方法会阻塞直到任务返回结果</strong></p>
<p>Future<V> 接口是用来获取异步计算结果的，说白了就是对具体的Runnable或Callable对象任务执行的结果</p>
<p>进行获取（<strong>get()</strong> ) , 取消（<strong>cancel()</strong>）,判断是否完成等操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//取消任务，如果取消任务成功返会true，如果取消任务失败返回false；</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interrupt：表示取消正在执行却没有执行完毕的任务，</span></span><br><span class="line"><span class="comment">     * true: 可以取消正在执行过程中的任务，</span></span><br><span class="line"><span class="comment">     * false:</span></span><br><span class="line"><span class="comment">     * 1.如果任务已经完成，interrupt =true or false，方法返回false，无法取消已经完成的任务，</span></span><br><span class="line"><span class="comment">     * 2.如果任务正在执行，interrupt=true 方法返回true，interrupt=false，方法返回false</span></span><br><span class="line"><span class="comment">     * 3.如果任务还没执行，interrupt=true or false， 方法返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> interrupt)</span></span>;</span><br><span class="line">    <span class="comment">//表示任务是否被取消成功，如果在任务正常完成前被取消成功，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//表示任务是否已经完成，完成返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取执行结果，会阻塞，会一直等到任务执行完毕之后才返回</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedExecption,ExecutionException</span>;</span><br><span class="line">    <span class="comment">//获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,ExecutionException,TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Future提供三种功能：</p>
<ul>
<li>判断任务是否完成；</li>
<li>能够中断任务；</li>
<li>能够获取任务执行结果；</li>
</ul>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>FutureTask类实现了RunnableFuture接口，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>,<span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口，所以其可以被当作Runnable被线程执行，也可以作为Future得到Callable的返回值；</p>
<p><strong>执行状态</strong></p>
<ul>
<li>未启动，FutureTask.run() 方法还没有被执行之前，处于未启动状态，创建一个FutureTask，并没有调用run()方法；</li>
<li>已启动，FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态</li>
<li>已完成，FutureTask.run()<strong>方法执行完正常结束，或者被取消，或者抛出异常结束</strong>，FutureTask处于已完成状态</li>
</ul>
<p><img src="https://i.loli.net/2020/05/03/OqIfesop9PyTShr.png" alt=""></p>
<p>FutureTask方法执行示意图：</p>
<p><img src="https://i.loli.net/2020/05/03/KsGxZ7n1wNmBFlc.png" alt=""></p>
<ul>
<li>当FutureTask处于未启动或者已启动状态时，如果此时调用FutureTask.get() 方法将导致调用线程阻塞</li>
<li>当FutureTask处于已完成时，执行FutureTask.get()方法导致调用线程立即返回结果，或者抛出异常</li>
</ul>
<p><img src="https://i.loli.net/2020/05/03/gUSpC1FNZLIozBR.png" alt=""></p>
<ul>
<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将会导致此任务永远不会执行，</li>
<li>当FutureTask处于已启动状态时，执行FutureTask.cancel()方法，如果是cancel(true)将以中断执行此任务线程的方式来试图停止任务，如果取消成功，cancel()返回true，表示任务取消成功，cancel(false)对正在执行的任务线程不产生影响，cancel() 返回false；</li>
<li>当FutureTask处于已完成状态时，执行cancel()返回false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FutureTask&lt;Callable&lt;V&gt; callable)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable,V result)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask 是Future接口的一个唯一实现类；</p>
<h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>使用Callable，Future，FutureTask最大的好处就是，通过这种方式创建线程， <strong>能够返回结果</strong>；</p>
<p>场景：计算一个数据，而这个数据的计算比较耗时，后面的程序需要使用到这个数据结果。</p>
<p>​            考虑Thread，Callable ；Callable是有返回值的，首选；</p>
<p>​             开启一个线程去计算，主线程继续做其他的事，后面需要使用到这个数据，使用Future获取就可以了。</p>
<ul>
<li><p><strong>使用Callable + Future获取执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算结果中...."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);<span class="comment">//模拟耗时操作</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    ExecutorService executor= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//创建Callable对象任务</span></span><br><span class="line">    Task task =<span class="keyword">new</span> Task();</span><br><span class="line">    <span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">    Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行结果为："</span>+result.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"未获取到结果"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"任务执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">实验结果</span><br><span class="line">--------</span><br><span class="line">计算结果中....</span><br><span class="line">主线程执行</span><br><span class="line">执行结果为：<span class="number">499500</span></span><br><span class="line">任务执行完毕</span><br><span class="line">--------</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用Callable+FutureTask获取执行结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"计算结果中...."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);<span class="comment">//模拟耗时操作</span></span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一种方式</span></span><br><span class="line">    ExecutorService executor = Executors.newCacheThreadPool();</span><br><span class="line">    Task task =<span class="keyword">new</span> Task();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">    <span class="comment">//FutureTask 作为 Future 加入到线程池中</span></span><br><span class="line">    executor.submit(futureTask);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    <span class="comment">//Task task =new Task();</span></span><br><span class="line">    <span class="comment">//FutureTask&lt;Integer&gt; futureTask =new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line">    <span class="comment">//FutureTask 作为 Runnable 加入到线程中</span></span><br><span class="line">    <span class="comment">//Thread thread =new Thread(futureTask);</span></span><br><span class="line">    <span class="comment">//thread.start();</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.err.println(<span class="string">"主线程执行"</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(futureTask.get()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        	System.out.println(<span class="string">"futureTask 执行结果为："</span>+futureTask.get());   </span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"futureTask.get()未获取到结果"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">----</span><br><span class="line">计算结果中....</span><br><span class="line">主线程执行</span><br><span class="line">futureTask 执行结果为： <span class="number">499500</span></span><br><span class="line">所有任务执行完毕    </span><br><span class="line">----</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  <strong>实现Runnable接口和实现Callable接口的区别</strong></p>
<ul>
<li>Runnable自从jdk1.1就有了，Callable是1.5之后有的</li>
<li>Callable规定的方法是call(), Runnable规定的方法是run();</li>
<li>Callable的任务执行后可返回值，而Runnable的任务是无返回值的；</li>
<li>call方法可以抛出异常，run方法不能</li>
<li>运行Callable任务可以拿到一个Future对象，表示异步执行计算的结果，在这个过程中，会检查计算是否完成，等待（阻塞手段）计算的完成，并获取计算的结果。因此通过Future对象可以了解任务的执行过程，可取消任务的执行，还可以获取执行的结果</li>
<li>加入到线程池运行，Runnable使用ExecutorService的execute方法，而Callable使用的是submit提交。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BCallable%E5%92%8CFuture/" data-id="ck9tzqm3c000es23b2h8h3fa8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" rel="tag">【Java并发编程】</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(四) ThreadPoolExecutor线程池各参数意义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/" class="article-date">
  <time datetime="2020-05-03T06:01:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/">Java多线程（四）ThreadPoolExecutor相关知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>为什么用使用线程池?</strong></p>
<p>耗时操作放到后台线程去执行；（网络，本地文件，数据库）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<p>那么某个时间点，迅速开启很多线程（加载列表图片，然后用户滑动列表）</p>
<p>问题：内存使用量飙升，thread占用内存，线程分配内存，工作，工作完成，释放内存，内存变化为开始没有分配，低占用内存, 分配内存给线程进行工作，高占用内存，线程完成任务，释放内存，低占用内存；</p>
<ul>
<li>内存抖动：短时间开启了很多线程，完成任务，线程都被回收，内存表现为低-高-低， 甚至可能会出现OOM</li>
<li>一个系统所能处理的线程数量是有限的，如果超过了最大承载量，性能会受到很大影响，而且还可能会影响用户后续操作；</li>
</ul>
<p>那么这个时候ThreadPool线程池的作用体现出来了。</p>
<p><strong>ThreadPoolExecutor详解</strong></p>
<p>Java提供的操作线程池的API：ThreadPoolExecutor 该类是实现了ExecutorService接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@corePoolSize</span>: 核心线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maximumPoolSize</span>: 线程池允许最大的线程数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@keepAliveTime</span>: 当线程空闲时间达到了keepAliveTime，该线程会退出，直到线程数量等于了			corePoolSize，如果想要线程池中的所有线程数量为0，那么可以设置allowCoreThreadTimeOut=true，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@allowCoreThreadTimeOut</span>: 是否允许核心线程池线程经历了空闲时间keepAliveTime退出</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@workQueue</span>:任务队列，pool.execute(runnable)提交的任务Task都会放在workQueue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadPoolExecutor pool =<span class="keyword">new</span> ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                                               <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                                               <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                                               TimeUnit unit,</span><br><span class="line">                                               BlockingQueue&lt;Runnable&gt; workQueue);</span><br></pre></td></tr></table></figure>

<h4 id="自定义一个ThreadPoolExecutor"><a href="#自定义一个ThreadPoolExecutor" class="headerlink" title="自定义一个ThreadPoolExecutor"></a>自定义一个ThreadPoolExecutor</h4><p>使用有界队列，和自定义ThreadFactory和拒绝策略的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize =<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime=<span class="number">10</span>;</span><br><span class="line">    TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">    BlockQueue&lt;Runnable&gt; workQueue= <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>);</span><br><span class="line">    ThreadFactory thredFactory = <span class="keyword">new</span> CustomThreadFactory();</span><br><span class="line">    RejectExecutionHandler handler =<span class="keyword">new</span> IgnorePolicy();</span><br><span class="line">    ThreadPoolExecutor executor =<span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">                                                       maximumPoolSize,</span><br><span class="line">                                                       keepAliveTime,</span><br><span class="line">                                                       unit,</span><br><span class="line">                                                       workQueue,</span><br><span class="line">                                                       threadFactory,</span><br><span class="line">                                                        handler</span><br><span class="line">                                                       );</span><br><span class="line">    executor.prestartAllCoreThreads(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        MyTask taks =<span class="keyword">new</span> MyTask(String.valueOf(i));</span><br><span class="line">        executor.execute(tasks);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNum = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r, <span class="string">"Thead-pool-"</span> + threadNum.getAndIncrement());</span><br><span class="line">            System.out.println(t.getName() + <span class="string">" has been created"</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IgnorePolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            System.err.println(r.toString() + <span class="string">" rejected"</span> +<span class="string">" remove the runnable :"</span>+ executor.remove(r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is Running"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"MyTask [Thread-pool-"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实验结果</span><br><span class="line">-----</span><br><span class="line">Thead-pool-<span class="number">1</span> has been created</span><br><span class="line">Thead-pool-<span class="number">2</span> has been created</span><br><span class="line">Thead-pool-<span class="number">3</span> has been created</span><br><span class="line">MyTask [Thread-pool-<span class="number">1</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">2</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">3</span>] is Running</span><br><span class="line">Thead-pool-<span class="number">4</span> has been created</span><br><span class="line">MyTask [Thread-pool-<span class="number">7</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">8</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">6</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">9</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">10</span>] rejected remove the runnable :<span class="keyword">false</span></span><br><span class="line">MyTask [Thread-pool-<span class="number">4</span>] is Running</span><br><span class="line">MyTask [Thread-pool-<span class="number">5</span>] is Running     </span><br><span class="line">-----</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>核心线程数为2，最大线程数为4，队列大小为2，任务数为10；</p>
<p>开启两个线程<strong>Thread-pool-1</strong>和<strong>Thread-pool-2</strong>执行任务<strong>MyTask</strong> [Thread-pool-1] 和 <strong>MyTask</strong> [Thread-pool-2]，</p>
<p>此时线程数为2，但是任务提交没有结束，此时任务<strong>MyTask</strong> [Thread-pool-3]</p>
<p>和<strong>MyTask</strong> [Thread-pool-6]发现核心线程数已经满了，则此时会加入到队列中进行等待，等待队列</p>
<p>大小为2，此时加入到的3和6的任务已经将队列占满了，这个时候线程池就会创建线程<strong>Thread-pool-3</strong>和<strong>Thread-pool-4</strong>来执行了任务<strong>MyTask</strong> [Thread-pool-3]和<strong>MyTask</strong> [Thread-pool-6]，执行完了，任务<strong>MyTask</strong> [Thread-pool-4]和<strong>MyTask</strong> [Thread-pool-5]进入队列，填充队列；</p>
<p>此时创建的线程数为4等于大于最大线程数，并且当前（<strong>MyTask</strong> [Thread-pool-4]和<strong>MyTask</strong> [Thread-pool-5]进行填充）的队列已经满了，就会拒绝其他任务<strong>MyTask</strong> [Thread-pool-7]，<strong>MyTask</strong> [Thread-pool-8]，<strong>MyTask</strong> [Thread-pool-9]，<strong>MyTask</strong> [Thread-pool-10]；</p>
<p>这个时候执行了任务<strong>MyTask</strong> [Thread-pool-4]和<strong>MyTask</strong> [Thread-pool-5]，执行完毕之后，队列清空；</p>
<p>总结：最大线程数加上队列大小，以及任务数可以推算出是否任务会不会拒绝</p>
<p>​            如果最大线程数+队列大小&lt;任务数，拒绝的任务个数为任务数-(最大线程数+)</p>
<p><img src="https://i.loli.net/2020/05/04/aZYztnQC3Psw5eD.png" alt="截屏2020-05-04 13.41.37.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)%20ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E5%8F%82%E6%95%B0%E6%84%8F%E4%B9%89/" data-id="ck9tzqm3e000ks23bhqyo57t2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" rel="tag">【Java并发编程】</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java多线程(二) 同步线程分组问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-05-03T03:34:35.000Z" itemprop="datePublished">2020-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98/">Java多线程（二）同步线程分组问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统的线程同步可以通过同步代码块或者同步方法实现；</p>
<p>如何实现同步，就需要借助一个同步监视器来完成；</p>
<p>要想确保线程之间能够同步，那么监视器对象对于同步线程之间就是同一个对象，</p>
<p>这样才会起到同步互斥效果。</p>
<p>单组同步函数：使用字节码（class）作为同步对象，是因为在内存中只存在一份某个类的字节码，</p>
<p>多组同步函数：就需要使用多个同步监视器对象，如果同步监视器使用同一个类的字节码，那么这样的话就成了一组同步函数；</p>
<p>来看以下实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     String source = <span class="string">"abc"</span>;</span><br><span class="line">     <span class="keyword">char</span>[] cs = source.toCharArray();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"--------------&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cs.length; j++) &#123;</span><br><span class="line">           System.err.println(cs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">    System.err.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"------------&gt;"</span>);</span><br><span class="line">        System.err.println(<span class="string">"the index is :"</span> + (i + <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">     System.err.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-1"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-2"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-3"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-4"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实验结果</span><br><span class="line">-------</span><br><span class="line"> &lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">4</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------Thread end---------&gt;   </span><br><span class="line">    </span><br><span class="line">-------</span><br></pre></td></tr></table></figure>

<p>由上述代码分析可知，执行结果，还是依次执行，说明Thread-1拿到锁，执行完毕，释放锁，这个时候Thread-2拿到锁，执行，释放，Thread-3拿到锁，执行，释放，Thread-4拿到锁，执行，释放，程序结束。</p>
<p>没有按照我们预想，print 和 printName 方法没有交替执行，也就是说他们对应的相应的同步监视器应该是同一个对象。</p>
<p>print方法和pritnName方法都是static的，而且又都是synchronized关键字修饰的，所以同步监视器对象都是当前类的字节码对象；</p>
<p>当一个线程执行了print或者printName方法，其他3个线程只有等该线程执行完毕之后才能接着执行；</p>
<p>按照多组函数同步的概念，一组的同步不应该影响其他组的执行；</p>
<p>改造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     String source = <span class="string">"abc"</span>;</span><br><span class="line">     <span class="keyword">char</span>[] cs = source.toCharArray();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"--------------&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cs.length; j++) &#123;</span><br><span class="line">           System.err.println(cs[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">    System.err.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造一下printName方法，使其同步监视器对象为String的字节码对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(String<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">     System.err.println();</span><br><span class="line">     System.err.println(<span class="string">"&lt;------Thread start---------\n"</span>);</span><br><span class="line">     System.err.println(<span class="string">"Current Thread name:"</span> + Thread.currentThread().getName()+<span class="string">"\n"</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.err.println(<span class="string">"------------&gt;"</span>);</span><br><span class="line">        System.err.println(<span class="string">"the index is :"</span> + (i + <span class="number">1</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     System.err.println(<span class="string">"------Thread end---------&gt;"</span>);</span><br><span class="line">     System.err.println();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-1"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-2"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-3"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"Thread-4"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实验结果</span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">3</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">4</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">5</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">6</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">7</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">8</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">9</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">10</span></span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">--------------&gt;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">------Thread end---------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;------Thread start---------</span><br><span class="line"></span><br><span class="line">Current Thread name:Thread-<span class="number">4</span></span><br><span class="line"></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">1</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">2</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">3</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">4</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">5</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">6</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">7</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">8</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">9</span></span><br><span class="line">------------&gt;</span><br><span class="line">the index is :<span class="number">10</span></span><br><span class="line">------Thread end---------&gt;</span><br><span class="line">    </span><br><span class="line">-------</span><br></pre></td></tr></table></figure>

<p>可以看出实验结果：Thread-1 执行完毕，Thread-3执行，然后在Thread-2执行，最后Thead-4执行，如此交替执行。</p>
<p>由此可以得出，同步线程分组的关键就是使用不同的同步监视器对象进行同步互斥；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%20%E5%90%8C%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%88%86%E7%BB%84%E9%97%AE%E9%A2%98/" data-id="ck9tzqm390009s23bepia7enb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" rel="tag">【Java并发编程】</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-线程进程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/02/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2020-05-02T13:46:35.000Z" itemprop="datePublished">2020-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/02/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/">线程进程概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###线程 进程 概念</p>
<p>@来自 <a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">https://www.zhihu.com/question/25532384</a></p>
<p><strong>进程和线程都是一个时间段的描述，是CPU工作时间的描述；</strong></p>
<p>CPU+RAM+各种资源（显卡，光驱，键盘，GPS等外设）构成电脑，</p>
<p>电脑运行，实际上就是CPU和相关寄存器以及RAM之间的事；</p>
<p><strong>基础事实</strong></p>
<p>CPU太快，寄存器执行效率仅能追上其脚步，RAM和其他的IO设备更是效率低下。</p>
<p>当多个任务要执行怎么办？ 轮流来？优先级高的来？无论是哪种策略，一句话获取到了CPU的时间片。</p>
<p><strong>必知事实</strong></p>
<p>执行一段程序代码，当得到CPU的时候，相关的资源必须到位，就是显卡，GPU的，然后CPU开始执行，除了CPU以外的所有构成了这个程序的执行环境，也就是我们定义的<strong>程序上下文</strong>，当程序执行完了或者是分配给他的执行时间用完了，就会被切换出去，在被切换出去的最后一步就是保存程序上下文，因为这是被CPU执行的运行环境。</p>
<p><strong>串联事实</strong></p>
<p>CPU看起来所有的任务都是一个一个的轮流执行的，具体的轮流方式就是：先加载程序A的上下文，然后执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B，保存程序B的上下文。</p>
<p><strong>定义</strong></p>
<p>进程是资源（CPU，内存）分配的基本单位，具有一定功能的程序关于数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）线程基本上不拥有系统资源，但是其拥有运行过程中必不可少的资源（程序计数器，栈）</p>
<img src="https://i.loli.net/2020/05/02/judtDcJC9MbxEk7.png" style="zoom:57%;" />

<p>​                            进程的地址空间</p>
<p>其中.data是已经初始化的全局和静态变量</p>
<p>.bss是未初始化的全局和静态变量</p>
<p>.text是已经编译的程序机器代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">0</span>;<span class="comment">//全局初始化区----&gt;.data</span></span><br><span class="line"><span class="keyword">char</span>* p1; <span class="comment">//全局未初始化区 ---&gt;.data</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[]=<span class="string">"abc"</span>;<span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span>* p3=<span class="string">"1235"</span>;<span class="comment">//1235\0在常量区，p3在栈上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">    p1=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//分配得来的10和20字节的区域就在堆区</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">"1234"</span>);<span class="comment">//1234\0放在常量区，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong></p>
<p>进程是资源分配的基本单位，线程是程序执行的基本单位</p>
<p>进程拥有自己的资源空间，每启动一个进程，系统就会为它分配地址空间，而线程与CPU资源分配无关，多个线程共享同一进程内的资源，各线程地址空间相互独立；</p>
<p>一个进程包含若干个线程；</p>
<p><strong>优劣</strong></p>
<p>1.线程之间通信更方便，同一进程下的线程共享全局变量，静态变量等数据，而进程之间的通信需要通过IPC进行；</p>
<p>2.线程调度与切换比进程快很多，同时创建一个线程的开销比进程要小很多；</p>
<p>3.多进程程序更加健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉，并不会对另外一个进程造成影响，因为进程有自己独立的地址空间；</p>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>@<a href="https://www.cnblogs.com/marsitman/p/11228684.html" target="_blank" rel="noopener">https://www.cnblogs.com/marsitman/p/11228684.html</a></p>
<p>生命周期包含5个阶段：新建，就绪，运行，阻塞，销毁</p>
<ul>
<li><p>新建：new方法， – new Thread();</p>
</li>
<li><p>就绪：调用start()方法，这时候线程处于等待CPU分配资源的阶段，谁先抢到CPU资源，谁先开始；</p>
</li>
<li><p>运行：当就绪的线程被调度并获得CPU资源时候，便进入运行状态，run方法定义了线程的操作和功能</p>
</li>
<li><p>阻塞：在运行状态的时候，可能由于某些原因导致运行状态变成了阻塞状态，比如sleep(), wait()之后线程处于阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify/notifyAll方法，唤醒的线程不会立即执行run方法，而是<strong>再次等待CPU分配资源进入运行状态。</strong></p>
</li>
<li><p>销毁：如果线程正常执行完毕后或者线程被提前强制性的终止或者出现异常导致结束，线程就要被销毁，释放资源；</p>
<p><img src="https://i.loli.net/2020/05/03/UbHchVonMB7vKkC.png" alt=""></p>
</li>
</ul>
<p><strong>新建状态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t =<span class="keyword">new</span> Thread();</span><br></pre></td></tr></table></figure>

<p>这里的创建，仅仅是Java的语言层面的创建，操作系统层面，真正的线程还没被创建，</p>
<p>只有调用了start() 方法之后，该线程才会被创建出来，进入到Runnable状态，</p>
<p><img src="https://i.loli.net/2020/05/03/HtGEMVPBTzgY4Kk.png" alt=""></p>
<p><strong>就绪状态</strong></p>
<p>调用start() 方法后，JVM进程会去创建一个新的线程，而此线程不会马上被CPU调度，进入Running状态，这里会有一个中间状态，就是Runnable状态，可以理解为等待被CPU调度的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/03/QuFvyiIzU53D8CV.png" alt=""></p>
<p>那么处于Runnable状态的线程能发生哪些状态转变？</p>
<p><img src="https://i.loli.net/2020/05/03/Eu81troqgw9aBhp.png" alt=""></p>
<p>Runnable状态的线程是无法直接进入Blocked状态和Terminated状态的，只有处于Running状态的线程（获得CPU调度执行权的线程才有资格进入到Blocked和Terminated状态，Runnabled状态的线程要么被切换为Running状态，要么被意外终止）</p>
<p><strong>运行状态</strong></p>
<p>当CPU调度发生了，并从任务队列中选中了某个Runnable线程时，该线程会进入Running执行状态，并且开始调用run()方法执行任务，那么处于Running状态的线程能发生哪些状态转变？</p>
<ul>
<li><p>被转换为Terminated状态，比如调用stop()方法</p>
</li>
<li><p>被转换为Blocked状态，</p>
<ul>
<li>比如调用了sleep，wait方法加入到waitSet中；</li>
<li>比如进行IO阻塞操作，查询数据库进入阻塞状态</li>
<li>获取某个锁的释放，而被加入该锁的阻塞队列中；</li>
</ul>
</li>
<li><p>该线程的时间片使用完了，CPU再次调度，进入到Runnable状态</p>
</li>
<li><p>线程主动调用yield方法，让出CPU资源，进入到Runnable状态</p>
<p><img src="https://i.loli.net/2020/05/03/QkDFudtEg6WXNZj.png" alt=""></p>
</li>
</ul>
<p><strong>阻塞状态</strong></p>
<ul>
<li><p>转换为Terminated状态，调用stop()方法，或者JVM意外Crash；</p>
</li>
<li><p>被转换为Runnable状态，阻塞时间结束，比如读取数据库的数据后</p>
</li>
<li><p>完成了指定时间的休眠，进入到Runnable状态</p>
</li>
<li><p>正在wait中的线程，被其他线程调用notify/notifyAll方法唤醒，进入到Runnable状态</p>
</li>
<li><p>线程获取到想要的锁资源，进入到Runnable状态；</p>
</li>
<li><p>线程在阻塞状态下被打断，如其他线程调用了interrupt方法，进入到Runnable状态</p>
<p><img src="https://i.loli.net/2020/05/03/nNi3HfX7jtlw8kS.png" alt=""></p>
</li>
</ul>
<p><strong>终止状态</strong></p>
<p>一旦线程进入到Terminated状态，意味着这个线程生命的终结；</p>
<ul>
<li>线程正常运行结束，生命周期结束；</li>
<li>线程运行过程中出现错误；</li>
<li>JVM异常结束，所有的线程生命周期均被结束；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/02/%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B/" data-id="ck9tzqm3u0010s23b4ta2bqt4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-UDP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/01/UDP/" class="article-date">
  <time datetime="2020-05-01T05:38:28.714Z" itemprop="datePublished">2020-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/01/UDP/">UDP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="UDP用户数据报协议"><a href="#UDP用户数据报协议" class="headerlink" title="UDP用户数据报协议"></a>UDP用户数据报协议</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>UDP是一个简单的面向数据报的运输层协议：</p>
<p>进程的每个输出操作都正好产生一个UDP数据报（强调单个），并组装成一份待发送的IP数据报；</p>
<p>对比：多个–》<strong>组成面向流字符</strong>的协议 TCP，应用程序产生的全体数据。</p>
<p><img src="https://i.loli.net/2020/05/01/MLH1a2Yobfk75dr.png" alt=""></p>
<p>​                                                        UDP的封装</p>
<p>UDP不提供可靠性：把应用程序传给IP层的数据发送出去，并不保证他们能够到达目的地。</p>
<p>应用程序必须关心IP数据报的长度，如果超过网络的MTU（2.8字节）就需要对IO数据报进行分片。</p>
<h3 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h3><p><img src="https://i.loli.net/2020/05/01/IBSHFaxXqf9QZRn.png" alt="UDP首部"></p>
<p>端口号表示发送进程和接收进程，TCP和UDP用目的端口号来获取来自IP层的数据，IP层把数据报分配给TCP和UDP（根据IP首部中协议字段值）</p>
<p>TCP端口和UDP端口相互独立，各自从属的端口由各自协议查看。</p>
<p>UDP长度字段指的是UDP首部和UDP数据的字节长度，该字段最小值为8个字节。</p>
<p>IP数据报长度指的是数据报全长，UDP数据报长度是全长减去IP首部的长度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hashwaney.github.io/2020/05/01/UDP/" data-id="ck9tzqm3t000zs23b02ha9xol" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI/" rel="tag">JNI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" rel="tag">【Java并发编程】</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/" rel="tag">面试集锦</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/JNI/" style="font-size: 15px;">JNI</a> <a href="/tags/%E3%80%90Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%91/" style="font-size: 20px;">【Java并发编程】</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/" style="font-size: 10px;">面试集锦</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java内存模型</a>
          </li>
        
          <li>
            <a href="/2020/05/04/%E9%9D%A2%E8%AF%95/">面试</a>
          </li>
        
          <li>
            <a href="/2020/05/04/Vultr/">Vultr</a>
          </li>
        
          <li>
            <a href="/2020/05/03/Android%E5%A4%8D%E4%B9%A0/">Android面试集锦（一）内存泄露篇</a>
          </li>
        
          <li>
            <a href="/2020/05/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)%20%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/">Java多线程（五）生产者和消费者模型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 HashWaney<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>